<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://www.lijunshuo.com/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.lijunshuo.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面试对线记录18 从输入URL到页面展示发生了什么</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9518/</link>
      <pubDate>Sun, 11 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9518/</guid>
      
        <description>最近的话又开始跟面试官对线了，最近的话好像是行情不好，投了很多的简历，面试没有几个，正好刚面试完，遇到了这个问题，不会真好记录一下。
总的过程大概是这样子的：
输入地址 在输入地址的时候，chorme浏览器已经在开始从自己本地的缓存中寻找输入的字符串可能对应的url，智能补全地址，或者直接从本地缓存中直接网页load出来 查看域名的ip地址 浏览器会解析这个域名，一般先从本地硬盘hosts文件开始查找，如果没有的的话，就会发送一个DNS请求到本地DNS服务器，这个本地DNS服务器一般是由运营商提供，比如说中国电信，中国移动啥的，如果本地DNS服务器的缓存中·有这条记录，那么就直接返回结果，如果没有，就像DNS根服务器进行查询，（递归过程），如果连根DNS服务器都没有的话，那么就会告诉本地DNS服务器，让他去域服务器上面去查询，并且给出域服务器的地址； 接下来本地DNS服务器就会向域服务器发送请求，比如。com 。org的域服务器，域服务器收到请求后，会告诉域名的解析服务器的地址； 最后的话，本地DNS服务器向域名的解析服务器发送请求，这样子就会收到一个域名和ip地址的对应关系，本地DNS服务器会把ip地址返回给用户，然后将这个对应关系保存到缓存中。 建立tcp连接 从上一步我们拿到对应的ip地址了，浏览器会用一个随机端口向服务器web程序80端口发起tcp连接请求，这个请求到达服务器端口，进入网卡，进入tcpip的协议栈，最后到达web程序，最终建立tcpip连接； 根据状态码处理请求 如果服务器会给浏览器响应一个301永久重定向响应，这样子浏览器就会重定向到www.google.com， 浏览器跟踪重定向地址，因为上一步浏览器重定向了一个新的地址，所以会发送一个新的http请求； 如果服务器返回一个200正常响应，，首先请求会先把你的请求发送到反向代理服务器中，比如nginx，nginx再请求应用服务器，应用服务器再将结果返回给客户端 服务器返回一个http响应 服务器会返回三部分：状态行，响应头，响应正文 浏览器显示html </description>
      
    </item>
    
    <item>
      <title>Vue学习笔记一 基础学习</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</link>
      <pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</guid>
      
        <description>Ruoyi-Vue
虚拟DOM 按照我的理解，浏览器是先分析html节点，然后构建成，一个DOM树，然后解析CSS文件和html节点上我们写的样式信息，生成一个样式表，最后将DOM树和样式表关联起来构建成一个Render树，每个DOM都有attach方法，接受样式信息，返回一个render对象，根据这些对象构建成一个Render树，然后浏览器根据Render树绘制出页面出来。但是这不是严格的，这三种是一种异步交叉的关系。这个就是整个一个正常流程. 在很老的开发中，在每次操作DOM树时，每操作一次就会走一遍上一段的流程，如果操作十次就会更新十次，所以这个是很难受的，所以虚拟DOM就是为了解决这个问题而设计出来的，如果在虚拟dom中操作十次，他不会更新十次，而是会将10次的更新保存到一个本地js对象中，然后再一次更新到（attach）到DOM树上。故而页面的更新都会记录在本地的js对象中，操作内存中的js对象明显比更新十次要快得多，更新快结束时直接映射成真实DOM然后再由浏览器绘制。 文件夹常规结构 .eslinttrc.js: 有个东西叫做eslint，这个就是eslint的配置文件，他是一个代码检查工具，用来检查你写的代码是不是规范的，这个东西在每个公司里面是不同滴！！! babel.config.js: 这个是另一个工具叫做Babel的配置文件，因为在前端中存在es6，es7等等的语法，但是你得考虑一下，我们有很多的浏览器，比如Google的Chorme，巨硬的Edge，还有火狐的Firfox，手机上开发的更多了，这个工具就是一个js编译器，用来把你写的代码转换为浏览器兼容的语法。 public：这个目录包含一些Webpack编译过程中没有加工处理过的文件，比如favicon.ico（项目图标）和index.html（这个是Vue应用来运行的模版文件，有点像Java中main函数的感觉） src：这不用说，这就是核心代码目录. 生命周期钩子 每个Vue组建在创建的时候都需要初始化，比如会进行数据监听和编译模版，更新DOM等等吧啦吧啦，这些动作就可以视为是生命周期钩子的函数，按照我的理解，有点类似页面上某个小块创建时，暴露出的几个api，通过这些api实现某些必须的操作。 Vue生命周期图示： 按照上面的图示所示，主要分成了五个生命周期 </description>
      
    </item>
    
    <item>
      <title>面试对线记录16 30G数据只有一个2G的内存应该怎么排序</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9516/</link>
      <pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9516/</guid>
      
        <description>最近东莞这边疫情真的很恐怖，我最近只能在家办公了，顺便最近的话也是金三银四，正好是跳槽的好时机，最近正好遇到了一个面试官问过我的小问题，拿出来分享一下，30G数据2G内存应该怎么排序呢。 刚开始的话我想的是先是把数据分成30份，然后两份两份用归并，但是后来发现有个问题就是，这么排序肯定是不能用的，因为归并完以后你没得操作了呀。所以后来我疯狂百度一波，发现我当初在看归并算法的时候，严奶奶那本书上讲的是二路归并，印象里只有二路归并了。实际上来说可以有很多路归并的算法，所以我们可以按照以前的思想，把30G数据分成30份，然后我们把每份数据读到内存里，随便用什么算法排序一下再导出去到磁盘，接下来的重点就是，我们从三十个块中可以读取1.5G/30的数据读到内存中，然后进行30路归并排序，并且将结果输出到缓冲区中，缓冲区满了就io到外部磁盘中，清空缓冲区，如果这三十个数据某一个用完了，就可以接着从磁盘中读取下一段，这样子就可以排序完成了。</description>
      
    </item>
    
    <item>
      <title>15. 三数之和</title>
      <link>https://www.lijunshuo.com/posts/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      
        <description>这道题的链接: 15. 三数之和
这道题刚一看到，首先想到的肯定是暴力法。。。如果在面对面试官写暴力法，估计就完犊子了，在这里的话，我刚开始想到的是深度优先，但是感觉怪怪的，不过我偷偷看了题解以后，发现可以用双指针来解决这个问题，因为我们可以换个思路，比如首先利用Java的api排个序，然后我们固定一个数，剩下的所有数我们就可以转化成双指针的问题来解决，具体来说就是
首先从左往右固定一个数A，当然我们要考虑去重问题（需要添加一个去重操作），如果这个数大于零，那就完犊子，直接return 如果这个数A小于零，那么我们就利用双指针，从数A的右边第一个数B和最后一个数C之间的所有数抽取出来做成一个新数列，然后我们从两边一直判断并计算是否B+C=-A，如果存在，就存到List中，一直迭代下去，就可以完成了！！！！ class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { Arrays.sort(nums); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for(int k = 0; k &amp;lt; nums.length - 2; k++) { if(nums[k] &amp;gt; 0) { break; } if(k &amp;gt; 0 &amp;amp;&amp;amp; nums[k] == nums[k-1]){ continue; } int i = k + 1, j = nums.length - 1; while(i &amp;lt; j) { int sum = nums[k] + nums[i] + nums[j]; if(sum &amp;lt; 0) { while(i &amp;lt; j &amp;amp;&amp;amp; nums[i] == nums[++i]); } else if (sum &amp;gt; 0){ while(i &amp;lt; j &amp;amp;&amp;amp; nums[j] == nums[--j]); } else { res.</description>
      
    </item>
    
    <item>
      <title>6. Z 字形变换</title>
      <link>https://www.lijunshuo.com/posts/6.-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/6.-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      
        <description>这道题的链接: 6. Z 字形变换
今天搞到微软苏州一位小姐姐的内推，感觉好开心哈哈哈哈哈哈，和微软小姐姐交流感觉小姐姐素质很高，没有我遇到过的大多公司HR那么豪横，经过初筛以后简历过了，不过人家建议我刷够300道力扣中等题再来试试，会一直保留我的HC，那还说什么，整吧那就，刷就完事了。
一般我刚开始碰到这种故事题，我总是感觉一脸懵逼，这讲的是啥玩意，我看了半天我总感觉这个Z字形变换的话，我感觉这个不是Z，应该是N。。。妈个鸡，说白了就是下面这个样子
0 6 12 18ar 1 5 7 11 13 17 2 4 8 10 14 16 3 9 15 这才明显嘛。要不一下子真的看不出来，我去&amp;hellip;
这道题的话，我们可以用最土的方法，借用一个正反变量，因为我们要拐弯，我们通过遍历字符串，然后按照字符串长度根据numRows和正反变量不断调整，进而实现
class Solution { public String convert(String s, int numRows) { if(numRows == 1){ return s; } boolean direction = false; int curRow = 0; List&amp;lt;StringBuilder&amp;gt; rowList = new ArrayList&amp;lt;&amp;gt;(); StringBuilder result = new StringBuilder(); for(int i = 0; i &amp;lt; numRows; i++){ rowList.add(new StringBuilder()); } for (char temp : s.</description>
      
    </item>
    
    <item>
      <title>面试对线记录10 CORS</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9510/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9510/</guid>
      
        <description>这个概念的话在今天我面试的时候接触到了，但是我的话可能是因为我做的项目比较菜，所以这部分并没有接触到过，所以我今天仔细学习和记录在这里。 这个玩意说白了就是跨域资源共享，就是说我们平时在不刷新页面时更新网页，在页面加载后从服务器请求数据以及在页面加载后从服务器接受数据等需求的背后，其实都是AJAX技术在默默支持，他使用XMLHttpRequest对象从web服务器请求数据，but不仅仅局限于XML，也可以是纯文本或者JSON文本，但是哟！！！！只能是同源情况下，这就很尴尬了，所以的话就有了CORS这个技术点，他可以允许浏览器向跨源服务器发出XMLHttpRequest请求。
这个技术需要浏览器和服务器支持，but现在浏览器都支持，除了老版本的ie浏览器，我都不想说微软就是个zz了。。。浏览器的话如果发现AJAX跨源，就会添加一些辅助措施来进行帮助请求，当然这种情况对用户来说是透明不感知的。
在CORS的视角下，它把请求分成两种，简单请求和非简单请求，对这两种请求会采用不同的措施。
比如简单请求就包括：HEAD，GET，POST，这几个请求如果跨域的话，就会在头信息中添加一个Origin字段，这个字段会记录该请求来自哪个源，Origin字段会包含协议，域名以及端口，服务器会根据这个值，来判断是否同意这个值。 在服务器拿到这个请求以后，如果Origin这个源不再服务器许可范围内，他就会返回一个正常的HTTP回应，；浏览器会检测这个回应的头信息的话会不会包含Access-Control-Allow-Origin字段，如果不包含，就会抛出一个错误，这种错误不会被状态码识别。
如果Origin这个指定的域名在许可范围内，服务器返回的响应就会多出几个头信息字段
Access-Control-Allow-Origin: http://api.xxxxx.com //这个字段是必须的 Access-Control-Allow-Credentials: true //可选，这个字段的值是bool类型，表示是否允许发送Cookie Access-Control-Expose-Headers: FooBar //这个字段置顶想拿到的字段的值 Content-Type: text/html; charset=utf-8 非简单请求中就包括PUT，DELETE以及Content-Type字段类型位application/json的请求，针对这些请求的跨域，浏览器会在正式通信之前增加一次HTTP查询请求，称为是“预检”请求； 浏览器会先查询服务器，当前页面所在的域名是否在服务器的许可名单之中，还有可以使用哪些HTTP动词以及头信息字段，只要得到肯定答复，就会发送正常的XMLHttpRequest请求，否则就会报错。
预检请求的头信息我找了一个例子，大概就是这样子：
OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT //必须字段 表示是个什么类型的请求 Access-Control-Request-Headers: X-Custom-Header //表示浏览器请求会额外发送的头信息字段 Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 大家可以看到请求方法就是OPTIONS，在这里表示这个请求就是用来询问的，头信息里，关键字段就是Origin，表示请求来自什么源。 服务器收到预检请求后，就会检查Origin和Access-Control-Request-Method以及Access-Control-Request-Headers等字段，确认允许跨源请求，就可以做出回应。
HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain Access-Control-Allow-Origin字段如果为*表示同意任何跨源请求 如果服务器否定了这个预检请求，会返回一个正常的HTTP回应，但是不包含上面的CORS头信息字段，这个时候浏览器就会认定服务器不同意预检请求，所以会触发错误，控制台就会报错。 预检之后的请求，头信息如下：</description>
      
    </item>
    
    <item>
      <title>102. 二叉树的层序遍历</title>
      <link>https://www.lijunshuo.com/posts/102.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/102.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      
        <description>这道题的链接: 102. 二叉树的层序遍历
这道题真的没什么好说的，层序遍历和前序遍历，后序遍历都是最基本的遍历,这要是写不出来就丢大人了，，，，其实昨天我就没写出来，，，尴尬 我的第一种做法就跟下面这个差不多，在这里的设计思路就是我们首先要注意层序遍历和二叉树的特点，层序遍历就是先父节点后是子节点，二叉树是根节点和子节点的关系，同一层之间除了父节点没有其他的关系。。。所以我们可以使用queue接口，也就是队列，队列是先塞进去的数据肯定是先出来，所以我们这样子想。。先把一层的父节点塞进来，然后先poll出一个父节点，把他的所有子节点放进队列。。。所以这又会引出来一个问题，我们咋知道哪几个是父节点哪几个是子节点，我们可以这样子想，我们在队列弹出之前提前记住队列元素的个数，这个时候就是全是一层的节点。下面就是代码的实现：
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;ret = new ArrayList&amp;lt;&amp;gt;(); if(root == null) { return ret; } Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeeNode&amp;gt;(); queue.offer(root); while (!queue.isEmpty()) { List&amp;lt;Integer&amp;gt; level = new ArrayList&amp;lt;&amp;gt;(); int currentLevelSize = queue.size(); for (int i = 0; i &amp;lt;= currentLevelSize; ++i){ TreeNode node = queue.poll(); level.add(node.val); if(node.left != null){ queue.offer(node.left); } if(node.right != null){ queue.offer(node.right); }) } ret.add(level); } return ret; } } </description>
      
    </item>
    
    <item>
      <title>剑指 Offer 42. 连续子数组的最大和</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      
        <description>这道题的链接: 剑指 Offer 42. 连续子数组的最大和 这种方法用的很巧，如果当前位置的数组和前一个数组加起来比加零大，那么就加起来，然后和已经存在的最大值比较，我们从头到尾扫描下来，使用变量存在的最大值就知道是多少了。代码如下：
class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; for(int i = 1; i &amp;lt; nums.length; i++) { nums[i] += Math.max(nums[i - 1], 0); res = Math.max(res, nums[i]); } return res; } } </description>
      
    </item>
    
    <item>
      <title>剑指 Offer 27. 二叉树的镜像</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      
        <description>这道题的链接: 剑指 Offer 27. 二叉树的镜像
这道题我们要注意哟，好多二叉树的问题解决方法都递归的方法，但是对我来说，我对递归理解的不深，讲真我一般只习惯迭代，接下来的代码就是递归方法，从根到底交换左右子树。
class Solution{ public TreeNode mirrorTree(TreeNode root) { if (root == null) { return null; } TreeNode left = mirrorTree(root.left); TreeNode right= mirrorTree(root.right); root.left = right; root.right = left; return root; } } 利用栈和队列遍历树的所有节点node，并交换每个node的左右子节点。
class Solution { public TreeNode mirrorTree(TreeNode root) { if(root == null) { return null; } Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(){{add(root);}}; while(!stack.isEmpty()){ TreeNode node = stack.pop(); if(node.left != null){ stack.add(node.left); } if(node.right !</description>
      
    </item>
    
    <item>
      <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      
        <description>这道题的链接: 剑指 Offer 53 - II. 0～n-1中缺失的数字
这道题的思路很简单，你想，如果一个从0开始的数组缺少一个数组，那么从缺少的部门开始，数字和下标肯定是不一致的，所以我们可以采用二分法，根据下标和数字的一致和不一致性找到不一致的开头，这就找到这个数字的位置。
所以就像一个力扣的大佬所说，排序数组中的搜索数组就可以用二分法解决。
class Solution { public int missingNumber(int[] nums) { int i = 0, j = nums.length - 1; while(i &amp;lt;= j){ int m = (i + j) / 2; if(nums[m] == m) { i = m + 1; } else { j = m - 1; } } return i; } } </description>
      
    </item>
    
    <item>
      <title>剑指 Offer 58 - I. 翻转单词顺序</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</guid>
      
        <description>这道题的链接: 剑指 Offer 58 - I. 翻转单词顺序
这道题我们刚开始审题，我感觉可以使用双指针来解决，具体思路就是从尾到头便利字符串树，然后将i，j两个变量定位在此，然后把i往前定位到倒数第一个单词的位置，新建一个StringBuilder接收单词加上空格，具体代码如下：
class Solution{ public String reverseWords(String s) { s = s.trim(); int j = s.length() - 1, i=j; StringBuilder res = new StringBuilder(); while(i &amp;gt;= 0){ while(i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) != &amp;#39; &amp;#39;){ i--; } res.append(s.substring(i + 1, j + 1) + &amp;#34; &amp;#34;); while(i &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(i) == &amp;#39; &amp;#39;) i--; j = i; } return res.toString().trim(); } } 第二种方法就是很土的方法，因为这句话是用空格分割的，我们就用空格分割成数组，然后从后向前遍历数组，存到新的StringBuilder中，转化成数组就成了。</description>
      
    </item>
    
    <item>
      <title>剑指 Offer 50. 第一个只出现一次的字符</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid>
      
        <description>这道题的链接: 剑指 Offer 50. 第一个只出现一次的字符
这道题的意思很好理解，说白了就是找到第一个只出现一次的字符。我的思路的话，可以使用Java中的Map记录所有出现的字符，然后第二遍遍历找到第一个只出现一次的字符
class Solution { public char firstUniqChar(String s) { Map&amp;lt;Character, Integer&amp;gt; frequency = new HashMap&amp;lt;Character, Integer&amp;gt;(); for(int i = 0; i &amp;lt; s.length(); ++i){ char temp = s.charAt(i); frequency.push(ch, frequency.getOrDefault(ch,0) + 1; } for(int i = 0; i &amp;lt; s.length(); ++i){ if(frequency.get(s.charAt(i) == 1)){ return s.charAt(i); } } return &amp;#39; &amp;#39;; } } 如果用C语言的话，代码如下：
struct hashTable { int key; int val; UT_hash_handle hh; } char firstUniqChar(char* s) { struct hashTable* position = NULL; int n= strlen(s); for(int i = 0; i &amp;lt; n; i++){ int ikey = s[i]; struct hashTable* tmp; HASH_FIND_INT(position, &amp;amp;ikey, tmp); if ( tmp !</description>
      
    </item>
    
    <item>
      <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
      <link>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</guid>
      
        <description>这道题的链接: 剑指 Offer 53 - I. 在排序数组中查找数字 I
这道题我们在和面试官对线时要注意，这个数据是排好序的，所以我们不能用最土的for循环遍历方法，写出来估计面试官就和你说拜拜了，我们应该使用二分法，我们可以用一个left索引和right索引来找数字target左右边界，然后一减就得到target的数量了。具体代码如下：
class Solution{ public int search(int[] nums, int target){ if (nums.length == 0) return 0; return binarySearch(nums, taget + 1) - binarySearch(nums, target); } private int binarySearch(int[] nums, int target){ int left = 0, right = nums.length; while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (nums[mid] &amp;lt; target){ left = mid + 1; } else { right = mid; } } return right; } } 还有另一个代码的写法如下：</description>
      
    </item>
    
    <item>
      <title>面试对线记录15 异常简述</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9515/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9515/</guid>
      
        <description>这个问题的话不是我在面试中问到的，可能是我最近面试面的少了？？？？，maybe，我正好仔细学习和梳理了一下Java异常的东西，所以在这里记录一下。
首先在Java中的异常的超类的话就是Throwable,接下来的下一层的话就是Error和Exception，Error类的话就是指的是Java运行过程中系统的内部错误和资源耗尽错误，应用程序不会抛出这种错误，但是他会尽他最大可能去安全关闭程序；
Exception的话又可以细分成RuntimeException和CheckedException。
RuntimeException主要有NullPointerException，ClassCastException等，如果出现RuntimeException，那肯定是程序员写错了。 CheckedException,比如IO问题导致的IOException和SQLEXception，这种异常都是发生在编译阶段，Java编译器会强制程序去捕获此类异常。 </description>
      
    </item>
    
    <item>
      <title>面试对线记录17 hash冲突的解决办法</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9517/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9517/</guid>
      
        <description>今天在和一位面试官对线时，这位面试官问的好多都是基础题，讲真，，，，学了这么久，好多都不会了，但是面试就是在不断的对线中越来越nb的嘛，所以开个小版块来记录一下。 hash算法按照我的理解，可以视为一个黑盒，把一个任意长的输入，通过Hash算法来变换成固定长度的输出，这个没什么好说的，Java中的HashMap底层原理粗略就是这样子。由此就可以引出一个叫做哈希表也可以叫做散列表的概念，就是说每一个输入都在哈希表中可以找到一个位置，一个萝卜一个坑的意思。但是什么算法都会有一些问题，比如有些输入在经过hash算法的处理，发现算出来的那个坑坑有萝卜了，这种现象就叫做hash冲突。也就引出来解决这个问题的三大方法：开放定址法，链地址法，再哈希法。
开放定址法 按照我的理解，就是说当发生哈希冲突时，萝卜B被分到一个萝卜A的坑坑了，这个时候就以萝卜A的地址为基准，根据再寻址的方法在找一个萝卜B的位置，如果找到这个地址了，还是冲突了，那就再寻址，一直到找到为止，寻址方法有线性探查(萝卜B就往A的后面位置一个一个数，一直到找到一个空位为止),二次探查(在萝卜B的周围反复横跳，+1，-1，+2，-2, &amp;hellip; ,+n,-n),一直到找到一个不冲突的位置为止，伪随机探测(使用一个伪随机数生成器，然后以萝卜B为基准，加上这个产生的随机数产生的位置)当然这个算法的前提就是整个地址空间不是FULL状态。 链地址法 这个就是HashMap的底层实现方法了，就是说在发生哈希冲突的时候，我们在这个坑坑上栽上个竹竿，然后把萝卜按照先后顺序挂在竹竿上。用代码来说就是在发生哈希冲突的哈希地址上建立一个链表（红黑树），哈希地址算出来相同的输入挂在链表(红黑树)上。 再哈希法 这个接着哈希就行了。。。。一直哈到有坑坑为止，有点像递归，这种方法很耗费时间 </description>
      
    </item>
    
    <item>
      <title>面试对线记录14 多线程基础</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9514/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9514/</guid>
      
        <description>前几天面了两个面试官，有一些基础的东西还是记得不太清楚，在这里记录一下
线程和进程
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。
进程是计算机重的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 创建线程的方式
继承Thread重写run方法；实现Runnable接口或者Callable接口；这两个接口的区别，就是Runable没有返回值，而callable有返回值。 sleep和wait的区别
sleep()继承自Thread，wait()继承自Object；sleep不会释放锁，wait()会释放锁，sleep()函数时间到的时候会自动恢复；而wait()函数可以使用notify()或者noitfyAll()函数直接唤醒； notify()和notifyAll()有什么区别
notifyAll()调用后会将全部线程由等待池移动到锁池，然后参与锁的竞争，竞争成功就会继续执行，如果不成功就会留在锁池等待锁被释放后再次参与竞争，而notify()只会唤醒一个线程，具体唤醒哪个就需要看虚拟机了。 run()和start()有什么区别
start()方法用于启动线程，run()方法用于执行线程的运行时代吗，run()可以重复调用，而start()只能调用一次。 什么是死锁 如果线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于2互相持有对方需要的锁，而发生的阻塞现象。 如何避免思索 尽量使用tryLock方法，设置超时时间，超时可以退出死锁； 尽量使用java.util.concurrent并发累代替自己手写锁； 尽量降低锁的使用粒度，尽量不要几个功能使用同一把锁； 尽量减少同步的代码块； synchronized底层实现 synchronized是由monitorenter和monitorexit实现的。monitor对象是对象同步的基本单元，在Java6之前的话monitor主要是依靠操作系统内部的互斥锁实现的，因为需要进行用户态和内核态的切换，所以同步操作是一个无差别的重量级操作，性能很低；在Java6之后，Java虚拟机优化了moitor的实现，提供了三种不同的锁：偏向锁，轻量级锁和重量级锁，大大改进了它的性能。 synchronized和volatile的区别 volatile是变量修饰符，synchronized是修饰类，方法和代码段；
volatile仅能实现变量的修改可见性，不能保证原子性；synchronized可是保证变量修改的可见性和原子性；
volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞； synchronized和ReentrantLock的区别 ReentrantLock使用起来比较灵活，但是需要手动释放锁；
synchronzied 不需要手动释放和开启锁，但是他比ReentrantLock大多数场景都性能相差很大，但是Java6对synchronized进行了很多的改进；
ReentrantLock只适用于代码块锁，而synchronized可用于修饰方法和代码块等等。 </description>
      
    </item>
    
    <item>
      <title>后端学习笔记四 Map的几个实现类杂谈</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/</guid>
      
        <description>Ruoyi-Vue 说到Map，不得不提的就是Java中的HashMap了，这个东西平时在写代码的时候是经常被使用的，这个东西的底层是由数组加上链表实现的，但是大家都知道的是HashMap是线程不安全的，因为多个线程对同一个HashMap做put操作的话，可能在某些情况下会有两个或者多个线程同时进行rehash操作，故而导致循环链表的出现，一旦出现就会死循环，cpu使用率会逐渐到达100%。 所以为了使用线程安全，又有了一个新的Map实现类：HashTable，说到多线程，肯定就会有锁的概念，为了实现HashTable的多线程同步，HashTable的底层实现了synchronized的锁结构，但是它效率比HashMap的效率要低一些，因为在多线程的情况下，HashTable会把整个结构全部锁住，为了解决遮盖1问题，在Jdk5中提出了ConcurrentHashMap这个新的数据结构。 这个ConcurrentHashMap提出的目的就是为了解决HashTable的低效率问题，使用了分段锁这个比较细粒度的锁，ConcurrentHashMap底层实现还是数组和链表，但是底层存储数据是一段一段的，每个段都有类似数组加上链表的结构，在进行get，put和remove操作时只锁住要用的段，但是以后每个段越来越大以后，分段锁的性能还是会下降的，但是在Jdk1.8以后，ConcurrentHashMap的底层实现变成了数组，链表/红黑树的形式。在链表中的元素个数超过默认的8个，数组的大小超过64后链表就变成红黑树了（想起这个树就脑壳痛），而且弃用分段锁，并且使用synchronized+CAS操作，目的就是为了降低锁的力度，因为synchronized是JVM支持的，在运行时会进行锁粗化，锁消除，锁自选等等操作。</description>
      
    </item>
    
    <item>
      <title>简单动态字符串</title>
      <link>https://www.lijunshuo.com/posts/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      
        <description>在Redis中的字符串表现形式并没有使用C的字符串形式,在这里的C字符串的表现是形式是以空字符结尾的字符串数组，而是使用一个叫做简单字符串(SDS)的抽象类型，在Redis源码中代码如下：
struct sdshdr { // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[]; }; 使用这个结构体的原因主要是在C语言中，如果用字符串数组代表字符串的话，首先肯定无法直观的知道字符串数组的长度，每次都需要遍历字符串数组来获取长度，而且字符串的话我们肯定还会进行字符串拼接和分割的操作，这样子就会涉及到空间的释放和分配，这不但会耗时，而且如果分配或者释放不当的话就容易造成内存泄漏或者缓冲区溢出的风险，所以使用上面的结构体是很有必要的。
在这个结构体中len代表字符串数组的已使用字节的数量，free代表未使用字节的数量，buf字符串数组用来保存字符串，这样子实现的话数组的长度获取就由O(n)将到了O(1)，并且也不会出现缓冲区溢出或者内存泄漏的情况。
并且为了优化SDS的字符串增长操作，Redis采用了空间预分配的策略，就是说，如果如果SDS的API对一个SDS进行修改比如字符串拼接时，它不但会为SDS分配拼接后所必需的空间，还会为SDS分配额外的未使用的空间。其中额外的未使用空间分配方案有如下两种：
如果对SDS进行修改后，SDS的长度如果小于1MB，那么分配等于SDS长度的为使用空间； 如果对SDS进行修改后，如果SDS的长度大于等于1MB,那么就分配1MB的未使用空间， 例如SDS的len为30MB，那么未使用空间的长度就分配1MB，所以SDS的buf数组长度就为30MB+1MB+1byte。 通过这种策略，SDS连续增长N次字符串的所需重分配次数从必定n次降低为最多N次。
为了优化SDS的字符串缩短操作，提出了惰性空间释放的方案，该方案实现如下： 当SDS的API要缩短SDS保存的字符串的时候，程序并不会立刻释放缩短的字节数，会先把这些字节数的数量纪录到free中，并且等待未来使用。比如说SDS的长度为30字节，然后SDS的API要对SDS释放8字节，他会清空数组后八个字节地址的数据，然后free+8，等到我们对SDS的字符串进行拼接5个字节的操作时，我们就不需要执行内存重分配，free中的8字节够它玩的了。
还有一点使用这个结构体的好处就是，如果我们使用C的字符数组来保存字符串时，只允许字符串的结尾处可以有空字符，而不允许字符串的中间有空字符，否则在读取长度时就会被截断丢失数据，在这个结构体，并不是由结尾空字符来读取字符串长度，而是使用len来读取字符串长度，这样子就不会丢失数据。 </description>
      
    </item>
    
    <item>
      <title>面试对线记录13 AOP</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9513/</link>
      <pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9513/</guid>
      
        <description>AOP这个东西我在和面试官对线的时候经常遇到，AOP又叫做面向切面编程，这个机制存在的目的就是为了解耦，AOP可以让一组类共享相同的行为，在OOP也就是面向对象编程中只能继承和实现接口，而且众所周知，在Java类中的继承只能单继承，不能多继承，故就用到了AOP这个机制。
再通俗一点就是说提供一个为一个业务实现提供切面注入的机制，通过这种方式，在业务运行中将定义好的切面通过切入点绑定到业务当中，目的是为了把一些特殊的逻辑绑定到业务中，比如在项目中记录日志的一个需求，通俗来说就是一个很简单的save操作，我们在写代码的时候一遍又一遍的重写和调用，这肯定会增加代码的耦合度，而且这样子更显的我们是码农。。。
接下来介绍一些aop的专有名词：
通知
需要完成的工作叫做通知，就是你写的业务逻辑中需要的比如事务和日志等提前定义好，然后再在需要的地方用起来。 切点 就是在类中筛选出一些方法来作为切点，形象的来说上面说的通知是定义了切面的动作或者执行动机的话，那么切点就是定义了执行的地点 切面
就是上面的通知和切点的结合，通知和切点共同定义了切面的全部内容，它是干什么的，什么时候在哪里执行。 引入 就是在不改变一个现有类的情况下，为该类添加属性和方法，可以在无需修改现有累的前提下，让他们具有新的行为和状态，就是吧上面说的切面用到目标类中去。 织入
把切面加入到程序代码中，切面在指定的连接点被织入到目标对象中，在目标对象的生命周期中有很多个点可以进行织入，比如编译期，类加载期，运行期等等 目标对象 被一个或者多个切面所通知的对象，Spring AOP是通过运行时代理实现的，这个对对象永远是一个被代理的对象。
举个例子就是 public class UserService{ void save(){} List list(){} } 如果我们想实现一个需求，就是在上面的save方法之前开启事务，在方法后关闭事务，在抛出异常时回滚事务，那么，在UserService中的所有方法都是连接点(JoinPoint),save()方法就是切点(Poincut),按照需求说的，我们在save()方法前后执行的方法就是通知(Advice),切点和通知合起来就是一个切面(Aspect).save()方法就是目标(target)。把想要执行的代码动态的加入到save()方法前后就是织入(Weaving).可能在工作中，有些大佬会把通知称为增强，其实想来也是对的，因为我们在我们需要操作的业务方法周围加上其他方法，这说白了就是对这个方法的增强。
接下来记录一下AOP的通知类型
before(前置通知)：在方法开始执行前执行 after(后置通知)：在方法执行后执行 afterReturning(返回后通知)：在方法返回后执行 afterThrowing(异常通知)：在抛出异常时执行 around(环绕通知)：在方法执行前和执行后都会执行
这五个通知的执行顺序就是 around &amp;gt; before &amp;gt; around &amp;gt; after &amp;gt; afterReturning </description>
      
    </item>
    
    <item>
      <title>面试对线记录12 线程实现和创建方式</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9512/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9512/</guid>
      
        <description>这段我也被问到过，我觉得还是要自己学习一下比较好，而且讲真，自己在使用过程中对这部分掌握的不是很熟，所以在这里学习记录一下
继承Thread类 在Java中有个类就叫做Thread类，这个类其实从根上来说也是继承了Runnable接口的一个实例，在这个类中启动线程的方法，就是通过Thread的start方法，但是要在这里注意一下，start方法其实是个native方法。还记得前面帖子中JVM中关于navite方法的东西吗，好吧其实我也忘了，，， 在JVM中 其实有个东西叫做本地方法栈 本地方法就是JVM为了运行Native方法的空间，因为Native方法很多的话都是用c实现的，所以他又被称为C栈，他跟Java虚拟机栈差不多，只不过本地方法栈是描述本地方法运行过程的内存模型。
在本地方法被执行时，在本地方法栈会创建一个栈帧，用于存放该方法的局部变量表，操作数栈，动态链接，方法出口信息等。
方法执行结束后，相应的栈帧也会出栈，并且释放内存空间，也会抛出StackOberFlowError和OutOfMemoryError异常。 注意，在HotSpot VM中就直接把本地方法栈和虚拟机栈直接合二为一了。
如果Java虚拟机本身不支持Native方法或者本身不依赖于传统栈，那么就可以不提供本地方法栈，如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。
在这里的话啥是本地方法（Native Method）呢，其实简单来说Native Method方法就是一个java调用非Java语言实现方法的接口，这个方法的方法体其实大部分都是非Java实现的，比如C或者其他语言实现，很多语言中其实都有，比如C++中调用C函数的话一般会在文件头那里写上 extern “c”告知GCC编译器去处理C函数时按照C函数去处理。
比如哈 public class IHaveNatives { native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ; } 这些方法的声明就是一些非Java方法在Java中的签名状态。
其实natvie这个关键字也可以与其他Java关键字连用，但是肯定不能和abstract一起连用，因为abstract在修饰方法的时候说明该方法没有方法体，但是native修饰的方法肯定是有方法体的，只是这个方法的方法体是由非Java方法实现的</description>
      
    </item>
    
    <item>
      <title>面试对线记录11 反射</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9511/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%9511/</guid>
      
        <description>首先在了解反射之前，需要了解一个静态编译和动态编译的概念，静态编译就是在编译时确定好类型绑定好对象，动态编译就是在运行时确定好类型，绑定对象。反射机制就可以实现动态编译，因为我们在开发很大的那种软件的时候，程序我们都知道，需要编译以后才能进行发布，如果没有反射，我们就需要把整个程序重新编译一份才可以实现功能的更新，如果采用反射的话我们就可以直接在运行时进行动态的创建和编译，没有原来那么麻烦，但是这毫无疑问。。。肯定对性能有影响。
首先要知道在Java中有个东西是Class类，这个玩意在Java中是最nb的一个类，怎么讲呢，如果稍微知道一点JVM就可以知道，在类加载的时候总共有五步，加载，验证，准备，解析和初始化，在加载阶段主要是将字节码加载到方法区还生成了这个类的java.lang.Class对象，这个对象就是用来记录被加载类的类型信息的对象，在Class类中存储了对应类的所有的信息，也是未初始化的信息（所有的方法，所有的构造函数，所有的字段或者说属性）。所以说这个玩意非常强大，可以从官方文档中知道，这个类是在JVM中的。而且这个Class类的构造器是私有的，也是说不能new一个，他是由JVM调用方法来创建该类的对象。
所以说通过反射，我们可以在运行时通过Class类，获得程序或者程序集中每个类型的成员和成员信息，在Java中反射可以在运行时判断任一对象所属类，构造一个类的对象，判断任意一个类所具有的成员变量和方法，通过反射甚至可以调用private方法。通过反射这个特性可以开发各种通用框架，比如Spring框架，通过配置xml文件动态加载所需要记载的对象。 在反射中有以下几种方法
//通过静态方法加载数据库驱动 Class.forName() //直接获取某一个对象的class Class&amp;lt;?&amp;gt;klass=int.class //调用某个对象的getClass()方法 Class&amp;lt;?&amp;gt;klass=str.getClass() //判断是否为某个类的实例 native方法 private native boolean isInstance(Object obj) 最后反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全性问题。</description>
      
    </item>
    
    <item>
      <title>面试对象线记录7 什么情况下会发生栈内存溢出</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%957/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%957/</guid>
      
        <description>这个问题不是我面试碰到的，但是是我在网上瞎看帖子，在一个帖子上看到的，感觉很有意思，所以学习并且记录一下。 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部方法表，操作数栈，动态链接，方法出口灯信息，局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化） 所以简单的来说，创建的栈帧超过了栈的深度，栈爆掉了，就会产生这种结果。 代码举例：
public class JvmTest { private int i = 0; public void a(){ System.out.println(i++); a(); } public static void main(String[] args) { JvmTest j = new JvmTest(); j.a(); } } 一直给他往死里递归，多nb的栈都得给他爆破掉哈哈哈哈哈</description>
      
    </item>
    
    <item>
      <title>面试对线记录9 JVM内存结构</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%959/</link>
      <pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%959/</guid>
      
        <description> 程序计数器
当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有； Java虚拟栈
存放基本数据类型，对象的引用，方法的出口等，线程私有； Native方法
和虚拟栈差不多，只是他服务于Native方法，线程私有； Java堆 Java内存中最大的一块，所有的对象实例和数组都存在在Java堆，GC回收的地方，线程共享 方法区 存放已被夹在的类信息，常量，静态变量，即时编译器JIT编译后的代码数据等 (永远代)，回收目标主要是常量池的回收和类型的卸载，各线程共享。 </description>
      
    </item>
    
    <item>
      <title>面试对线记录8 如何设计一个秒杀系统</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%958/</link>
      <pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%958/</guid>
      
        <description>今天和面试官二轮对线时碰到了这个问题，害，我是个菜狗，Java实在是太小白了，当时只是说出了几个点，但是应该说的都不对，所以开个帖子仔细整理一下。 不管是完成一个系统还是完成一个功能，肯定要提前做好分析，然后罗列出所有开发和设计中可能遇到的的问题点，然后根据问题点找到解决方案，接下来设计架构，根据架构进行开发和检测，我认为一个开发应该是这样子的。 so经过我网上遍寻资料以及整理，我觉得一个秒杀系统遇到的问题有以下几点：
高并发：既然是秒杀系统，那肯定是千军万马在一秒间过独木桥，所以系统如何扛得住高并发的请求；
超卖：怎么防止某个商品卖超了；
接口防刷：这个就涉及安全了，现在网上到处都是各种连点器，秒杀脚本等等各种奇怪的软件，目的就是为了代替人来抢某个商品，所以遇到这种刷单问题怎么解决；
秒杀url可见 这是目前我能想到的一些问题，首先在这之前，我觉得要考虑一个问题，我们现在考虑的是如何把一个秒杀系统维持住的问题，换句话说就是如何实现一个秒杀系统业务的问题，but我们没有考虑一个问题，如果秒杀系统被玩的不好，出现缓存雪崩，缓存击穿，缓存穿透等等情况，巨量的流量直接打在数据库上，数据库服务器boom了，所有的后台服务一起挂掉了。。。我们肯定不能连带其他业务一起挂，所以以上考虑的前提就是先提前分库分表，gg也不能大家一起gg。
接口防刷
面对可见url的问题，因为有些稍微懂一点点技术的老铁都知道在chorme中可以看到前端的接口，所以我们在设计秒杀接口的时候一定要注意秒杀接口的可见性，不能在秒杀系统开始之前就有一堆人用程序来刷接口，所以在秒杀时间开始前，不能拿到秒杀接口，只有秒杀开始时，才返回秒杀地址和验证MD5，用户拿到这两个数据才可以进行秒杀； 如果多个账号在一个ip地址发出多个请求，我们可以在设计系统时检测ip请求频率，如果超过某个阈值，那么就弹出验证码或者其他东西进行验证； 当然最多的情况是一个账号发出多个请求，我们可以限定这个用户在发起一次秒杀后，需要等待才可以发起另一次请求，从而减少多个请求的压力，或者使用redis标志位，每个用户的请求都尝试在Redis中插入一个secondKill的标志位，成功插入的才可以执行后续的秒杀逻辑，其他的就被过滤掉。 当然还有多个账号不同ip发起不同请求，我们可以采用检测账号等级的或者检测性别的骚操作来减少操作。。。 前端进行优化的话，可以采用验证码，降低用户的请求速度，或者采用限购的策略，抢到一个商品后，不能再抢第二个，或者说将前端静态数据缓存在离用户最近的地方，比如用户浏览器，CDN或者服务器的缓存中。 2.超卖问题 缓存预热 在秒杀之前，需要将秒杀商品信息提前缓存到Redis中，这么秒杀开始时就直接从Redis读取，也就是缓存预热。 </description>
      
    </item>
    
    <item>
      <title>面试对线记录5 String详解</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%955/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%955/</guid>
      
        <description>前几天和面试官对线时，面试官问了我一个问题，String类型常用方法有哪些，讲真哈，我平时用idea习惯了，早就不记得这些方法了，，，，丢人呀，所以在这里记录一下 String类型常用方法如下：
indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 这些函数中我基本都用过，这些意思大概都知道，也没什么好说的，下面我就扩展一下，讲一讲String这个类型。 在这里要说是的，String这个类型是不可变的。因为在idea中看源码的话，我们可以看到String继承了Serializable, Comparable, CharSequence，被final修饰，被final修饰的话说明该类不能被继承，内部的核心是一个被final修饰的char数组，被final修饰后的字段创建后不可变，but这是个数组奥（数组的老巢都在堆区中），只是说明地址不会变，但是地址上对应的数据还是会变的，所以这个数组被sun公司的程序员铁铁用private修饰，使得不向外暴露这个数组，并且用final严禁继承，简直是天衣无缝。。。。 我在网上查了很多种原因，总的说来大概就是由结果推断的原因。。。按照我的理解吧，这几种原因有以下几种：
避免安全问题 简单的来说，主要是String类型的数据在很多场景下用的很多，比如网络地址url，文件地址path以及Java很强大的反射机制的String参数等等，如果这些参数可变的话，那就会引起很重的安全问题。进而来说的话，我们储存密码的时候，非常不建议用String类型接收，因为String类型的所有对象会一直留在字符串缓冲池中，一直到gc把它给清除掉。这样子会有很大的安全隐患。 加快字符串处理速度 因为String类型时不可变的，所以也就保证了hashcode的唯一性，所以我们在创建String类型时不用重新计算hashcode，这样子速度就很快，比如Map中就很喜欢用String当作key。 3.便于实现字符串池 因为在Java中设计了一个字符串池，会在堆空间中开辟一块存储空间来做字符串池，如果不创建这个池子的话，那么我们每声明一个就会创建一个String对象，这样子很是浪费空间和降低速度，有了字符串池以后，我们就可以在创建对象之间在池子中找找是否之前创建过这个对象，这样子就加快速度，节省cpu时间，这一切都建立在字符串不可变的情况下，如果可变了，那池子就失效了。。。 </description>
      
    </item>
    
    <item>
      <title>面试对象线录6 数据库索引</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%956/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%956/</guid>
      
        <description>前几天和面试官对线时，发现自己虽然平时用到的数据库索引，but还是对索引的总体了解很少，所以我在这里好好记录一下以供学习和后面的面试官对线时使用，哈哈哈哈哈 在数据库里面，这里说的都是关系型数据库，如果这个库的数据非常爆炸，有上万条或者上亿条，我们就可以用到索引这个工具来提高查询速度；索引可以对一个数据列或者几个数据列一起进行预排序，这样子在查询的时候不用扫描整个表，直接定位到位置，快如闪电,大概意思是算法上说的空间换时间。 当然建立索引时，也不是随便哪个列都适合建的，比如某一列的数据不相同的很多，那么建索引的话，查询的速度相比原来就提升的很快，如果某一列的数据比如性别，只有男和女，那这列的数据建立索引的话也可以建，但是建了以后的速度提升不会很明显，，，所以索引这个东西。。还是在该用的时候来用。 不过有一点要注意的是，一般每个表的主键，数据库会自动给他建索引，因为主键本来就是互不相同的嘛。 接下来要说的就是mysql的索引种类，mysql索引主要分成普通索引，唯一索引，主键索引，组合索引，以及全文索引。
普通索引(key) 举个例子，下面的这个key就是普通索引，key在数据库中是一个物理结构，他包含两层意思，一层是约束作用，一层是索引作用； CREATE TABLE `phpcolor_ad` ( `id` mediumint(8) NOT NULL AUTO_INCREMENT, `name` varchar(30) NOT NULL, `type` mediumint(1) NOT NULL, `code` text, PRIMARY KEY (`id`), KEY `type` (`type`) ); 2. 唯一索引 unique key 和主键索引其实也是差不多的，也是要求不能有重复，不过主键索引只能有一个，但是唯一索引可以有很多个，而且，唯一索引可以有一条内容为空。主键就不允许有空值。 3. 主键索引 primary key 就是上面说的建立在主键上的索引，这种索引每张表只能有一个，而且有主键索引的这个列不允许有空值。 4. 组合索引 </description>
      
    </item>
    
    <item>
      <title>面试对线记录2 如何理解面向对象</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%952/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%952/</guid>
      
        <description>这个问题真的是逢面必问，而且我真的每次都答不好，所以我要在博客上记录一下，总的来说，面向对象有四大特性：抽象，继承，封装，多态；
抽象按照我的理解，就是将一类对象的共同特征总结出来构造类的过程，抽象的话可以分成数据抽象和行为抽象，抽象只关注对象的属性和行为，不关注具体的实现； 封装就是把数据和操作数据的方法绑定在一起，对数据的访问只能通过特定的接口来访问，说白了就是隐藏具体的实现，只给外人一个可以用的接口，这样子可以提高代码的复用性和安全性。 继承的话就是说很多类都有一种或者一类相同的属性和行为时，就可以把他们抽取到一个类中，这些类不用挨个定义这些属性和行为，直接从这个类继承即可。 多态的话就是是由继承产生的不同的类，其对象对同一消息会做出不同的响应，简单的来说就是龙生九子，各有不同的意思。 接下来就是一些我在网上学习这一部分的东西时，我查到的虽然这几天面试官没有跟我对线过程中问道的，也可能跟面试官对线过程中遇到的一个基础问题：面向对象的五大设计原则； 单一职责原则 说白了就是在设计类的时候，只让他干一个或者说一类的事情，不要分配太多的东西给一个类，每个类只设计一种功能就好了，因为功能多了的话，到了后面维护的时候简直是一场灾难，这个维护的工作落到谁手里，谁就会骂娘。。。。。(我就遇到过这种事情) 开放封闭原则 按照我的理解，就是说我们在设计类的时候，我们要对扩展开放，要对修改封闭，说白了就是类设计完了以后，就可以独立完成工作，不用进行一些修改； 但是在面对新的需求的时候，我们就可以对类做出良好的扩展，以适应新的情况。 里氏代换原则 emmm，这个说白了，就是对上面说的继承的具体描述，在一个稳定运行的系统中，子类可以直接代替基类进行正常服务，但是基类不能替换子类，因为子类有一些完全不同与基类的特征，按照我的理解，就是多态 依赖倒置原则 就是说白了，要在脑壳中形成一个金子塔的形象，顶层就是抽象，下层是具体，或者说一个树，树根就是抽象，是面向具体的根基，而具体就是从根上长出来的各种枝杈。具体描述就是高层模块不能依赖于底层模块，这些模块应该都依赖于抽象，抽象不依赖具体，而具体依赖抽象。(很拗口，哈哈哈哈哈哈)，平时在软件过程设计过程中，如果两个或者多个类，模块都存在紧密的耦合关系的话，我们可以考虑将他们分离开来，形成接口和实现，也就是说在依赖之间定义一个抽象的接口，然后高层的模块可以调用这个接口，底层模块可以继承并且实现这个接口，通过这样子降低耦合关系，维持住抽象的稳定性。也就是面向接口编程。 接口隔离原则 这个原则有点像是单一职责原则的补充，就是说我们在设计接口的时候要使得每个接口的功能偏单一一些，不要使得一个接口内部的功能函数拥有太多种的功能，因为一个类和另一个类的依赖应该建立在最小的接口上，如果他继承了一个胖接口，但是有些其他种类的功能用不到，如果以后系统庞大起来，对这个胖接口进行更改的话，对整个系统的影响就好像一颗老鼠屎坏了一锅粥一样的级别。所以按照实际情况不要设计胖接口。 </description>
      
    </item>
    
    <item>
      <title>面试对线记录3 如何理解重载和重写</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%953/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%953/</guid>
      
        <description>这个问题真的是离谱，我自己清楚，但是总是说不清楚，有一位我的领导说过我，如果你感觉自己知道但是说不出来，那就说明你还是没掌握，那我就在博客里在记录一遍。 重写就是字面意思，就是在子类中把父类中的方法重写一遍，说详细点就是子类继承父类的方法，也就是在保持方法名，参数类标和返回类型相同的情况下对这个函数进行重写，再说详细点，就是serices层，我对一个接口中的函数进行具体的实现，实现这个接口中某个函数的具体功能。。。。再具体点，，，，我也说不明白了，打扰了 重载这个就很有意思了，就是说两个函数可以在参数类型或者参数个数甚至是参数顺序不同的情况下同名，这两个函数就形成互相重载，but如果仅仅是返回值类型不同，那抱歉不是重载。</description>
      
    </item>
    
    <item>
      <title>面试对线记录4 如何理解抽象类和接口</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%954/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%954/</guid>
      
        <description>抽象类的话，他肯定符合Java中类的定义，他不能多继承，只能单继承，而接口可以多实现，抽象类可以被任意权限修饰符public，private，protected以及默认，abstract等属性修饰，并且抽象类中可以有抽象方法，也可以有非抽象方法。but接口的修饰符只能被Public 或者friendly和abstracted修饰，而且接口中的成员变量的话只能是public static final的，其他类型的会报错，，并且成员变量必须赋初值，不然通不过编译；方法必须是public abstracted 从另一个方面来说，抽象类的抽象形式是对属性和行为进行抽象，而接口是对行为进行抽象 再从设计的角度来说的话，抽象类设计的目的就是自下而上，子类需要所以我设计抽象类，继承抽象类就是为了实现这个类属性和行为，或者说从子类中发现公共的部分，然后泛化为抽象类，子类继承父类即可；接口的设计就是自上而下，接口的目的就是规范了一类行为，某个类需要这类行为我就继承这个接口，或者说抽象类体现的是一种继承关系，比如男人女人可以抽象成一个感情抽象类，因为男女都有感情嘛；而接口只是定义了一类规则，but他不要求接口的实现和接口本质上一致，男人和狗子都会有求偶的行为，我们不能把男人和狗算成一个父类。(单身狗不算哈，，，，呜呜呜) 还有个经常问的进阶问题，抽象类中必须要有抽象方法才行嘛，答案肯定是不一定要有抽象方法，比如只有一个静态方法，也不会报错的；而且抽象类不能被final修饰，因为被final修饰的类就不能被继承了，那就没啥意义了，所以在idea中会报错。</description>
      
    </item>
    
    <item>
      <title>面试对线记录1 hash冲突的解决办法</title>
      <link>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%951/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%951/</guid>
      
        <description>今天在和一位面试官对线时，这位面试官问的好多都是基础题，讲真，，，，学了这么久，好多都不会了，但是面试就是在不断的对线中越来越nb的嘛，所以开个小版块来记录一下。 hash算法按照我的理解，可以视为一个黑盒，把一个任意长的输入，通过Hash算法来变换成固定长度的输出，这个没什么好说的，Java中的HashMap底层原理粗略就是这样子。由此就可以引出一个叫做哈希表也可以叫做散列表的概念，就是说每一个输入都在哈希表中可以找到一个位置，一个萝卜一个坑的意思。但是什么算法都会有一些问题，比如有些输入在经过hash算法的处理，发现算出来的那个坑坑有萝卜了，这种现象就叫做hash冲突。也就引出来解决这个问题的三大方法：开放定址法，链地址法，再哈希法。
开放定址法 按照我的理解，就是说当发生哈希冲突时，萝卜B被分到一个萝卜A的坑坑了，这个时候就以萝卜A的地址为基准，根据再寻址的方法在找一个萝卜B的位置，如果找到这个地址了，还是冲突了，那就再寻址，一直到找到为止，寻址方法有线性探查(萝卜B就往A的后面位置一个一个数，一直到找到一个空位为止),二次探查(在萝卜B的周围反复横跳，+1，-1，+2，-2, &amp;hellip; ,+n,-n),一直到找到一个不冲突的位置为止，伪随机探测(使用一个伪随机数生成器，然后以萝卜B为基准，加上这个产生的随机数产生的位置)当然这个算法的前提就是整个地址空间不是FULL状态。 链地址法 这个就是HashMap的底层实现方法了，就是说在发生哈希冲突的时候，我们在这个坑坑上栽上个竹竿，然后把萝卜按照先后顺序挂在竹竿上。用代码来说就是在发生哈希冲突的哈希地址上建立一个链表（红黑树），哈希地址算出来相同的输入挂在链表(红黑树)上。 再哈希法 这个接着哈希就行了。。。。一直哈到有坑坑为止，有点像递归，这种方法很耗费时间 </description>
      
    </item>
    
    <item>
      <title>后端学习笔记三 RuoYi的log配置分析</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/</guid>
      
        <description>Ruoyi-Vue 在SpringBoot中，可以发现在每次idea启动时会发现控制台会输出很多log信息(其实只要是SpringBoot项目在Console窗口都会打印log信息)，正好我在RuoYi的项目中我也看到了logback.xml的文件，这个文件说白了就是控制Console如何打印日志的，我记得刚开始学框架时，看网上的教程感觉Spring框架真恶心，代码没写几行，倒是天天配xml，自从学了SpringBoot框架就发现自己好久没配xml了，log这里就是在配xml。。（满满的回忆～～～） RuoYi的logback.xml内容如下：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!-- 日志存放路径 --&amp;gt; &amp;lt;property name=&amp;#34;log.path&amp;#34; value=&amp;#34;/Users/junshuoli/Projects/Ruoyi-Vue/logs&amp;#34; /&amp;gt; &amp;lt;!-- 日志输出格式 --&amp;gt; &amp;lt;property name=&amp;#34;log.pattern&amp;#34; value=&amp;#34;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{20} - [%method,%line] - %msg%n&amp;#34; /&amp;gt; &amp;lt;!-- 控制台输出 --&amp;gt; &amp;lt;appender name=&amp;#34;console&amp;#34; class=&amp;#34;ch.qos.logback.core.ConsoleAppender&amp;#34;&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;pattern&amp;gt;${log.pattern}&amp;lt;/pattern&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 系统日志输出 --&amp;gt; &amp;lt;appender name=&amp;#34;file_info&amp;#34; class=&amp;#34;ch.qos.logback.core.rolling.RollingFileAppender&amp;#34;&amp;gt; &amp;lt;file&amp;gt;${log.path}/sys-info.log&amp;lt;/file&amp;gt; &amp;lt;!-- 循环政策：基于时间创建日志文件 --&amp;gt; &amp;lt;rollingPolicy class=&amp;#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;#34;&amp;gt; &amp;lt;!-- 日志文件名格式 --&amp;gt; &amp;lt;fileNamePattern&amp;gt;${log.path}/sys-info.%d{yyyy-MM-dd}.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;!-- 日志最大的历史 60天 --&amp;gt; &amp;lt;maxHistory&amp;gt;60&amp;lt;/maxHistory&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;pattern&amp;gt;${log.pattern}&amp;lt;/pattern&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;filter class=&amp;#34;ch.qos.logback.classic.filter.LevelFilter&amp;#34;&amp;gt; &amp;lt;!-- 过滤的级别 --&amp;gt; &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt; &amp;lt;!-- 匹配时的操作：接收（记录） --&amp;gt; &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt; &amp;lt;!</description>
      
    </item>
    
    <item>
      <title>后端学习笔记二 理解IOC</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/</guid>
      
        <description>Ruoyi-Vue IOC中文又被称为控制反转(依赖注入)，用文邹邹的话来说就是组件之间的依赖关系在运行期确定，或者说容器动态的将依赖关系注入到组件之中，总的来说比如很早之前声明对象的时候，我们想要创建一个类的对象都是手写new一个，而使用IOC之后我们可以通过IOC，然后IOC会给我们一个对象，不用自己来声明。 从底层来说的话，如果通过IOC的方式来创建对象，就可以进入容器IOC的bean缓存池，从而降低程序的创建开销，等到以后再用时直接从bean缓存池中拿，比创建的方式要快得多。 所以来控制反转的控制就是说，原有的每次程序员控制创建对象的方式交给IOC容器来控制，反转就是以前是我们主动创建对象，现在是IOC容器创建后被动注入到被注入的对象中。动作人不一样了。</description>
      
    </item>
    
    <item>
      <title>后端学习笔记一 注解学习</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEruoyi%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</guid>
      
        <description>Ruoyi-Vue
注解 在Java中注解是一个很优雅的一种编程手段，主要是从JDK5引入的一种注释机制，用来将很多任何的信息和元数据和程序元素相关联，为程序元素提供更加直观的更加明了的说明。按照我的理解，注解这种东西主要是为了简化很多冗余代码的编写，通过一个注解，可以免于编写很多冗余的代码。
@Controller</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E5%9B%9B%E7%AF%87-%E8%AF%A6%E8%A7%A3start_up%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E5%9B%9B%E7%AF%87-%E8%AF%A6%E8%A7%A3start_up%E5%87%BD%E6%95%B0/</guid>
      
        <description>大周六的无聊的很，不如来继续看这一大段开源代码，这一次我们按照Github上面那位大佬推荐的步骤来看推荐的步骤来看，先看start_up函数。 说多无益，先上该段代码：
int startup(u_short *port) { int httpd = 0; int on = 1; struct sockaddr_in name; httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(&amp;#34;socket&amp;#34;); memset(&amp;amp;name, 0, sizeof(name)); name.sin_family = AF_INET; name.sin_port = htons(*port); name.sin_addr.s_addr = htonl(INADDR_ANY); if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;on, sizeof(on))) &amp;lt; 0) { error_die(&amp;#34;setsockopt failed&amp;#34;); } if (bind(httpd, (struct sockaddr *)&amp;amp;name, sizeof(name)) &amp;lt; 0) error_die(&amp;#34;bind&amp;#34;); if (*port == 0) /* if dynamically allocating a port */ { socklen_t namelen = sizeof(name); if (getsockname(httpd, (struct sockaddr *)&amp;amp;name, &amp;amp;namelen) == -1) error_die(&amp;#34;getsockname&amp;#34;); *port = ntohs(name.</description>
      
    </item>
    
    <item>
      <title>开源项目Tinyhttpd第二篇 详解sizeof关键字</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%BA%8C%E7%AF%87-%E8%AF%A6%E8%A7%A3sizeof%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%BA%8C%E7%AF%87-%E8%AF%A6%E8%A7%A3sizeof%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      
        <description>Tinyhttpd 接上一篇文章，接下来我们要注意的关键字是sizeof。sizeof在我的印象里都是一个用来返回某个数据类型所占的内存，然而前段时间被人家问到了基本用法，都忘了。。。。所以写出来整理一下。 1.普通用法
sizeof(type)/sizeof var_name sizeof是以字节形式给出了所操作数据的大小。前一种的格式都喜闻乐见，而后一种对我来说很少见，当用这种格式时主要是用来操作变量和对象，但是如果是操作一个类型必须要添加括号。但是由这里也可以看出来sizeof并不是函数！！！！因为一个正常的函数是需要加括号的。 而且sizeof也不是一种操作符！！！！，为什么这么说呢，可以看下面的例子： int a=0; cout&amp;lt;&amp;lt;sizeof(a=4)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl; 这段程序的输出结果为：
4 0 在当初在其他大佬的博客上看到这段程序时，我发现这个东西真的好迷，因为我认为答案是4和3，后来把sizeof看作是一种编译预处理就想的过去了，因为显然在sizeof处理阶段显然括号内并没有编译，而是被替换成类型int。
sizeof不能用来操作未知存储大小的数据类型，未知内容的结构和联合类型,void类型。例如： sizeof(max);//int max() sizeof(char_v);//char char_v[MAX]，MAX未赋值 sizeof(void); 以上用法全都是错误的！！！ 以上用法全都是错误的！！！ 以上用法全都是错误的！！！
sizeof的基本用法 上面的这些7788的东西，说出来没有什么依据，下面通过一些常用的用法来认识sizeof的用法： sizeof(char);/sizeof(signed char)/sizeof(unsigned char) sizeof(p);//int *p或者string *p或者char********* sizeof(a);//int a[10] sizeof(b);//char b[]=&amp;#34;hello&amp;#34;; 1和2的结果都是1,不管是什么类型，sizeof后的结果都是取决于操作系统的，在32位操作系统上面就是4，在64位上就是8,sizeof(a)在这里等价于数组长度乘以sizeof(int),换句话说：sizeof(a)=10*sizeof(int)。sizeof(b)等于6，原因是因为字符串后面一般都会有个”\0”，这个。。。预编译符会算进去的！！！！！
int b[20]={3,4}; char c[2][3]={&amp;#34;aa&amp;#34;,&amp;#34;bb&amp;#34;}; sizeof(b);\\20*4 sizeof(c);\\6 以上的例子可以看的出来sizeof的值并不取决于赋值的情况，数组的大小取决于它在编译时被分配的空间，也就是各维度乘以数组元素的大小。
函数的sizeof使用方法 sizeof并不能测量整个函数占用的内存大小！！！！而是测量数组返回值类型的大小。但是要在这期间注意不能对返回值类型为空或者仅仅对一个函数名求值，在函数有参数时，必须加上参数表！！！ 进阶用法 诡异的函数对齐问题 众所周知，C语言中存在这两种类型：struct和union，而在C++中区别于c语言存在更复杂的class类型，而对这三种数据类型操作时，代码如下： struct sample { double a; char b; int c; } 对于刚开始入门的兄弟来说，sizeof(sample)=sizeof(double)+sizeof(char)+sizeof(int)。。。然而并不是这样子的，编译器对一些变量的起始地址做了“对齐”处理。在默认情况下，编译器规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。在32位系统中，具体偏移方法如下：
Char //偏移量必须为sizeof(char)即1的倍数 int //偏移量必须为sizeof(int)即4的倍数 float //偏移量必须为sizeof(float)即4的倍数 double //偏移量必须为sizeof(double)即8的倍数 Short //偏移量必须为sizeof(short)即2的倍数 结构体中的变量在申请空间时，是按照顺序来申请空间，并且按照上面所示的对齐方式来调整位置，并且按照上述要求填充空字节。这样子说跟没说一样，所以说个例子吧：</description>
      
    </item>
    
    <item>
      <title>开源项目Tinyhttpd第三篇 由上一篇sizeof引出的对指针和数组的思考</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%94%B1%E4%B8%8A%E4%B8%80%E7%AF%87sizeof%E5%BC%95%E5%87%BA%E7%9A%84%E5%AF%B9%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%94%B1%E4%B8%8A%E4%B8%80%E7%AF%87sizeof%E5%BC%95%E5%87%BA%E7%9A%84%E5%AF%B9%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      
        <description>指针和数组，恕我直言，我从17年第一次接触C++语言开始，我就认识这俩玩意儿了。。。。但是我提到指针，就跟见了鬼一样，我记得逼乎上谁说的。。C语言最有特色的部分就是指针了，指针的好处就是灵活。。然而坏处就是太TM灵活了！！用这个东西容易搞出很多莫名其妙的bug和令人非常难懂的语句段来，所以很多高级语言比如C#和Java和前端三大语言虽然都源自于C语言，但是不约而同的没有继承指针这一特性。好的废话不多说，让我们来解析这俩玩意儿吧～～～～
指针 指针是用来表示或者存储一个存储器地址，这个地址的值直接指向存在该地址的对象的值。指针所占内存单元的大小（即其内容）是跟操作系统的地址位数有关，在32位系统中，指针所占的内存单元就是4个字节，在64位系统中，指针所占的内存单元就是8个字节，在16位系统中，指针所占的内存单元就是2个字节。但是指针所占的内存单元的大小与变量类型无关。 首先事先说明&amp;quot;*&amp;ldquo;由三个用途，具体如下： 1） 表示乘法（喜闻乐见）； 2） 表示定义一个指针变量，用这个符号和普通变量分开； 3） 表示获取指针指向的数据，是一种间接的操作。 int a=10; int *p=&amp;amp;a; ++*p;//将p所指向的内容加上1后赋值给y，这个语段等价于++(*p) *p++;//和楼上的方法是一样的，等价于(*p)++,也就是说++和*的优先级一样的 /////////////////////////////////// /////////////////////////////////// int a=0; int *pa=a; *&amp;amp;a;//等价于*(&amp;amp;a)表示先取a的地址，然后再取这个地址上的数据，说白了还是a。。。。 &amp;amp;*pa;//等价于&amp;amp;(*pa)表示先取pa指向的数据，也就是a的值嘛，然后再取该数据的地址，说白了还是pa。。。。重要的是分析的过程不是结果哈。。。 关于指针的解析问题(基于32位操作系统) int num=97; int *p1=&amp;amp;num; 假设num的地址为0028FF40，换句话说，p1和p2的值就是0028FF40，都不重要哈，但是指针的类型决定了这个指针指向的内存的字节数并且如何解释这些信息，听起来有点绕口，让我们用这个例子来说吧： num的地址如上述所述是0028FF40,所以p1和p2的解析思路如下：
p1:从地址0028FF40开始,p1是int类型的指针，int在上一节说过占四个字节，因此从前往后数上四个字节，将这四个字节的二进制数解析，结果是97； p2:从地址0028FF40开始，p2是char类型的指针，char占一个字节，然后解析这一个字节的二进制数。。结果是a； 从上述可以知道，同样的地址，如果解析的方式不同，得到的数据可是天壤之别，因为就有了一个奇葩的指针：void类型的指针 void指针只是保存了指针的值，没有类型信息，也就是说，你只知道它的地址，但是你并不知道它的解析方式，换句话说你不知道它指向的数据是什么类型的，所以在使用该指针时严禁解引用！！！！！！！，如果非要用它的话必须要将这种指针进行类型转换才能使用！！！！！ 指针和数组（以下叙述基于32位系统） 数组的定义喜闻乐见，就是一个连续占有一段内存单元的变量集合，它的数组名可以看作是一个指针，代表数组的首地址。例子如下： int a[10]; int *p=a;//和int *p=&amp;amp;a[0]等价,p=p[0]=a[0]=*a,p+i=p[i]=a[i]=*(a+i) p[n]==*(p+n); p[n][m]=*(*(p+n)+m); //sizeof(p)在32位系统中为四个字节。 //sizeof(a)的值为40个字节。在这里数组名a被看作整个数组的代表。 //在上面的p+1并不是指向下一个地址，而是指向下一个元素，在这里要注意哟，这里是有区别的，比如p指向的是int类型的数组首个元素，而p+1大家都知道是指向的是第二个元素，”下一个地址“就是p往后挪了一个字节，“下一个元素”就是p往后挪了四个字节（如果数组是int类型的）或者往后挪了一个字节（如果数组是char类型的）。综上所述，*p是第一个元素的内容，*(p+1)是第二个元素的内容，p+1是第二个元素的地址。 令人恶心的数组指针和指针数组 这个东西还是很难记住的。。。。还是多看多记吧。。。贼难受呀～～～～ nt *p[10];//指针数组，数组里有十个元素，每个元素都是int型的指针 //[]的优先级比*要搞，p先与[]结合，是一个数组，然后int*修饰数组的内容，所以这是10个指向int类型的指针。 int (*p)[10];//数组指针，()的优先级比[]高，*和p构成一个指针的定义，int修饰的是数组的内容，即是每个元素，数组在这里没有名字，是一个匿名数组，所以p是一个指针，指向了一个匿名的包含int类型的数组。可以理解为int(*)[10]p </description>
      
    </item>
    
    <item>
      <title>桨声灯影里的秦淮河</title>
      <link>https://www.lijunshuo.com/posts/%E6%A1%A8%E5%A3%B0%E7%81%AF%E5%BD%B1%E9%87%8C%E7%9A%84%E7%A7%A6%E6%B7%AE%E6%B2%B3/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E6%A1%A8%E5%A3%B0%E7%81%AF%E5%BD%B1%E9%87%8C%E7%9A%84%E7%A7%A6%E6%B7%AE%E6%B2%B3/</guid>
      
        <description>朱自清 强烈建议与网易云音乐的清华大学广播台文学组的播音：朱自清《桨声灯影里的秦淮河》一同食用！！！！！ 链接 ：桨声灯影里的秦淮河
一九二三年八月的一晚，我和平伯同游秦淮河，平伯是初泛，我是重来了。我们雇了一只“七板子”，在夕阳已去，皎月方来的时候，便下了船。于是桨声汩——汩，我们开始领略那晃荡着蔷薇色的历史的秦淮河的滋味了。 秦淮河里的船，比北京万生园，颐和园的船好，比西湖的船好，比扬州瘦西湖的船也好。这几处的船不是觉着笨，就是觉着简陋，局促；都不能引起乘客们的情韵，如秦淮河的船一样。秦淮河的船约略可分为两种：一是大船；一是小船，就是所谓“七板子”。大船舱口阔大，可容二三十人。里面陈设着字画和光洁的红木家具，桌上一律嵌着冰凉的大理石面。窗格雕镂颇细，使人起柔腻之感。窗格里映着红色蓝色的玻璃；玻璃上有精致的花纹，也颇悦人目。“七板子”规模虽不及大船，但那淡蓝色的栏杆，空敝3的舱，也足系人情思。而最出色处却在它的舱前。舱前是甲板上的一部，上面有弧形的顶，西边用疏疏的栏杆支着。里面通常放着两张藤的躺椅。躺下，可以谈天，可以望远，可以顾盼两岸的河房。大船上也有这个，但在小船上更觉清隽罢了。舱前的顶下，一律悬着灯彩；灯的多少，明暗，彩苏的精粗，艳晦，是不一的，但好歹总还你一个灯彩。这灯彩实在是最能勾人的东西。夜幕垂垂地下来时，大小船上都点起灯火。从两重玻璃里映出那辐射着的黄黄的散光，反晕出一片朦胧的烟霭；透过这烟霭，在黯黯的水波里，又逗起缕缕的明漪。在这薄霭和微漪里，听着那悠然的间歇的桨声，谁能不被引入他的美梦去呢？只愁梦太多了，这些大小船儿如何载得起呀？我们这时模模糊糊的谈着明末的秦淮河的艳迹，如《桃花扇》及《板桥杂记》里所载的。我们真神往了。我们仿佛亲见那时华灯映水，画舫凌波的光景了。于是我们的船便成了历史的重载了。我们终于恍然秦淮河的船所以雅丽过于他处，而又有奇异的吸引力的，实在是许多历史的影象使然了。
秦淮河的水是碧阴阴的；看起来厚而不腻，或者是六朝金粉所凝么？我们初上船的时候，天色还未断黑，那漾漾的柔波是这样恬静，委婉，使我们一面有水阔天空之想，一面又憧憬着纸醉金迷之境了。等到灯火明时，阴阴的变为沈沈了：黯淡的水光，像梦一般；那偶然闪烁着的光芒，就是梦的眼睛了。我们坐在舱前，因了那隆起的顶棚，仿佛总是昂着首向前走着似的；于是飘飘然如御风而行的我们，看着那些自在的湾泊着的船，船里走马灯般的人物，便像是下界一般，迢迢的远了，又像在雾里看花，尽朦朦胧胧的。这时我们已过了利涉桥，望见东关头了。沿路听见断续的歌声：有从沿河的妓楼飘来的，有从河上船里度来的。我们明知那些歌声，只是些因袭的言词，从生涩的歌喉里机械的发出来的；但它们经了夏夜的微风的吹漾和水波的摇拂，袅娜着到我们耳边的时候，已经不单是她们的歌声，而混着微风和河水的密语了。于是我们不得不被牵惹着，震撼着，相与浮沉于这歌声里了。从东关头转湾，不久就到大中桥。大中桥共有三个桥拱，都很阔大，俨然是三座门儿；使我们觉得我们的船和船里的我们，在桥下过去时，真是太无颜色了。桥砖是深褐色，表明它的历史的长久；但都完好无缺，令人太息于古昔工程的坚美。桥上两旁都是木壁的房子，中间应该有街路？这些房子都破旧了，多年烟熏的迹，遮没了当年的美丽。我想像秦淮河的极盛时，在这样宏阔的桥上，特地盖了房子，必然是髹漆得富富丽丽的；晚间必然是灯火通明的，现在却只剩下一片黑沉沉！但是桥上造着房子，毕竟使我们多少可以想见往日的繁华；这也慰情聊胜无了。过了大中桥，便到了灯月交辉，笙歌彻夜的秦淮河，这才是秦淮河的真面目哩。
大中桥外，顿然空阔，和桥内两岸排着密密的人家的景象大异了。一眼望去，疏疏的林，淡淡的月，衬着蔚蓝的天，颇像荒江野渡光景；那边呢，郁丛丛的，阴森森的，又似乎藏着无边的黑暗：令人几乎不信那是繁华的秦淮河了。但是河中眩晕着的灯光，纵横着的画舫，悠扬着的笛韵，夹着那吱吱的胡琴声，终于使我们认识绿如茵陈酒的秦淮水了。此地天裸露着的多些，故觉夜来的独迟些；从清清的水影里，我们感到的只是薄薄的夜——这正是秦淮河的夜。大中桥外，本来还有一座复成桥，是船夫口中的我们的游踪尽处，或也是秦淮河繁华的尽处了。我的脚曾踏过复成桥的脊，在十三四岁的时候。但是两次游秦准河，却都不曾见着复成桥的面；明知总在前途的，却常觉得有些虚无缥缈似的。我想，不见倒也好。这时正是盛夏。我们下船后，藉着9新生的晚凉和河上的微风，暑气已渐渐消散；到了此地，豁然开朗，身子顿然轻了——习习的清风荏苒在面上，手上，衣上，这便又感到了一缕新凉了。南京的日光，大概没有杭州猛烈；西湖的夏夜老是热蓬蓬的，水像沸着一般，秦淮河的水却尽是这样冷冷地绿着。任你人影的憧憧，歌声的扰扰，总像隔着一层薄薄的绿纱面幂似的；它尽是这样静静的，冷冷的绿着。我们出了大中桥，走不上半里路，船夫便将船划到一旁，停了桨由它宕着。他以为那里正是繁华的极点，再过去就是荒凉了；所以让我们多多赏鉴一会儿。他自己却静静的蹲着。他是看惯这光景的了，大约只是一个无可无不可。这无可无不可，无论是升的沉的，总之，都比我们高了。
那时河里热闹极了；船大半泊着，小半在水上穿梭似的来往。停泊着的都在近市的那一边，我们的船自然也夹在其中。因为这边略略的挤，便觉得那边十分的疏了。在每一只船从那边过去时，我们能画出它的轻轻的影和曲曲的波，在我们的心上；这显着是空，且显着是静了。那时处处都是歌声和凄厉的胡琴声，圆润的喉咙，确乎是很少的。但那生涩的，尖脆的调子能使人有少年的，粗率不拘的感觉。也正可快我们的意。况且多少隔开些儿听着。因为想像与渴慕的做美，总觉更有滋味；而竞发的喧嚣，抑扬的不齐，远近的杂沓，和乐器的嘈嘈切切，合成另一意味的谐音，也使我们无所适从，如随着大风而走。这实在因为我们的心枯涩久了，变为脆弱；故偶然润泽一下，便疯狂似的不能自主了。但秦淮河确也腻人。即如船里的人面，无论是和我们一堆儿泊着的，无论是从我们眼前过去的，总是模模糊糊的，甚至渺渺茫茫的；任你张圆了眼睛，揩净了眦垢，也是枉然。这真够人想呢。在我们停泊的地方，灯光原是纷然的；不过这些灯光都是黄而有晕的。黄已经不能明了，再加上了晕，便更不成了。灯愈多，晕就愈甚；在繁星般的黄的交错里，秦淮河仿佛笼上了一团光雾。光芒与雾气腾腾的晕着，什么都只剩了轮廓了；所以人面的详细的曲线，便消失于我们的眼底了。但灯光究竟夺不了那边的月色；灯光是浑的，月色是清的。在浑沌的灯光里，渗入一派清辉，却真是奇迹！那晚月儿已瘦削了两三分，她晚妆才罢，盈盈的上了柳梢头。天是蓝得可爱，仿佛一汪水似的；月儿便更出落得精神了。岸上原有三株两株的垂杨树，淡淡的影子，在水里摇曳着。它们那柔细的枝条浴着月光，就像一支支美人的臂膊，交互的缠着，挽着；又像是月儿披着的发。而月儿偶尔也从它们的交叉处偷偷窥看我们，大有小姑娘怕羞的样子。岸上另有几株不知名的老树，光光的立着；在月光里照起来，却又俨然是精神矍铄11的老人。远处——快到天际线了，才有一两片白云，亮得现出异彩，像是美丽的贝壳一般。白云下便是黑黑的一带轮廓；是一条随意画的不规则的曲线。这一段光景，和河中的风味大异了。但灯与月竟能并存着，交融着，使月成了缠绵的月，灯射着渺渺的灵辉，这正是天之所以厚秦淮河，也正是天之所以厚我们了。
这时却遇着了难解的纠纷。秦淮河上原有一种歌妓，是以歌为业的。从前都在茶舫上，唱些大曲之类。每日午后一时起；什么时候止，却忘记了。晚上照样也有一回，也在黄晕的灯光里。我从前过南京时，曾随着朋友去听过两次。因为茶舫里的人脸太多了，觉得不大适意，终于听不出所以然。前年听说歌妓被取缔了，不知怎的，颇涉想了几次——却想不出什么。这次到南京，先到茶舫上去看看。觉得颇是寂寥，令我无端的怅怅了。不料她们却仍在秦淮河里挣扎着，不料她们竟会纠缠到我们，我于是很张皇了，她们也乘着“七板子”，她们总是坐在舱前的。舱前点着石油汽灯光亮，眩人眼目：坐在下面的，自然是纤毫毕见了——引诱客人们的力量，也便在此了。舱里躲着乐工等人，映着汽灯的余辉蠕动着；他们是永远不被注意的。每船的歌妓大约都是二人；天色一黑，她们的船就在大中桥外往来不息的兜生意。无论行着的船，泊着的船，都要来兜揽的。这都是我后来推想出来的。那晚不知怎样，忽然轮着我们的船了。我们的船好好的停着，一只歌舫划向我们来了；渐渐和我们的船并着了。烁烁的灯光逼得我们皱起了眉头；我们的风尘色全给它托出来了，这使我不安了，那时一个伙计跨过船来，拿着摊开的歌折，就近塞向我的手里，说：“点几出吧！”他跨过来的时候，我们船上似乎有许多眼光跟着。同时相近的别的船上也似乎有许多眼睛炯炯的向我们船上看着。我真窘了！我也装出大方的样子，向歌妓们瞥了一眼，但究竟是不成的！我勉强将那歌折翻了一翻，却不曾看清了几字；便赶紧递还那伙计，一面不好意思地说：“不要，我们……不要。”他便塞给平伯，平伯掉转头去，摇手说：“不要！”那人还腻着不走。平伯又回过脸来，摇着头道：“不要！”于是那人重到我处，我窘着再拒绝了他。他这才有所不屑似的走了。我的心立刻放下，如释了重负一般。我们就开始自白了。
我说我受了道德律的压迫，拒绝了她们；心里似乎很抱歉的。这所谓抱歉，一面对于她们，一面对于我自己。她们于我们虽然没有很奢的希望；但总有些希望的。我们拒绝了她们，无论理由如何充足，却使她们的希望受了伤；这总有几分不做美了。这是我觉得很怅怅的。至于我自己，更有一种不足之感。我这时被四面的歌声诱惑了，降伏了；但是远远的，远远的歌声总仿佛隔着重衣搔痒似的，越搔越搔不着痒处。我于是憧憬着贴耳的妙音了。在歌舫划来时，我的憧憬，变为盼望；我固执的盼望着，有如饥渴。虽然从浅薄的经验里，也能够推知，那贴耳的歌声，将剥去了一切的美妙；但一个平常的人像我的，谁愿凭了理性之力去丑化未来呢？我宁愿自己骗着了。不过我的社会感性是很敏锐的；我的思力能拆穿道德律的西洋镜，而我的感情却终于被它压服着。我于是有所顾忌了，尤其是在众目昭彰的时候。道德律的力，本来是民众赋予的；在民众的面前，自然更显出它的威严了。我这时一面盼望，一面却感到了两重的禁制：一，在通俗的意义上，接近妓者总算一种不正当的行为；二，妓是一种不健全的职业，我们对于她们，应有哀矜勿喜之心，不应赏玩的去听她们的歌。在众目睽睽之下，这两种思想在我心里最为旺盛。她们暂时压倒了我的听歌的盼望，这便成就了我的灰色的拒绝。那时的心实在异常状态中，觉得颇是昏乱。歌舫去了，暂时宁静之后，我的思绪又如潮涌了。两个相反的意思在我心头往复：卖歌和卖淫不同，听歌和狎妓不同，又干道德甚事？——但是，但是，她们既被逼的以歌为业，她们的歌必无艺术味的；况她们的身世，我们究竟该同情的。所以拒绝倒也是正办。但这此意思终于不曾撇开我的听歌的盼望。它力量异常坚强；它总想将别的思绪踏在脚下。从这重重的争斗里，我感到了浓厚的不足之感。这不足之感使我的心盘旋不安，起坐都不安宁了。唉！我承认我是一个自私的人！
平伯呢，却与我不同。他引周启明先生的诗，“因为我有妻子，所以我爱一切的女人；因为我有子女，所以我爱一切的孩子。”他的意思可以见了。他因为推及的同情，爱着那些歌妓，并且尊重着她们，所以拒绝了她们。在这种情形下，他自然以为听是对于她们的一种侮辱。但他也是想听歌的，虽然不和我一样。所以在他的心中，当然也有一番小小的争斗；争斗的结果，是同情胜了。至于道德律，在他是没有什么的；因为他很有蔑视一切的倾向，民众的力量在他是不大觉着的。这时他的心意的活动比较简单，又比较松弱，故事后还怡然自若；我却不能了。这里平伯又比我高了。
在我们谈话中间，又来了两只歌舫。伙计照前一样的请我们点戏，我们照前一样的拒绝了。我受了三次窘，心里的不安更甚了。清艳的夜景也为之减色。船夫大约因为要赶第二趟生意，催着我们回去；我们无可无不可的答应了。我们渐渐和那些晕黄的灯光远了，只有些月色冷清清的随着我们的归舟。我们的船竟没个伴儿，秦淮河的夜正长哩！到大中桥近处，才遇着一只来船。这是一只载妓的板船，黑漆漆的没有一点光。船头上坐着一个妓女；暗里看出，白地小花的衫子，黑的下衣。她手里拉着胡琴，口里唱着青衫的调子。她唱得响亮而圆转；当她的船箭一般驶过去时，余音还袅袅的在我们耳际，使我们倾听而向往。想不到在弩末的游踪里，还能领略到这样的清歌！这时船过大中桥了，森森的水影，如黑暗张着巨口，要将我们的船吞了下去。我们回顾那渺渺的黄光，不胜依恋之情；我们感到了寂寞了！这一段地方夜色甚浓，又有两头的灯火招邀着；桥外的灯火不用说了，过了桥另有东关头疏疏的灯火。我们忽然仰头看见依人的素月，不觉深悔归来之早了！走过东关头，有一两只大船湾泊着，又有几只船向我们来着。嚣嚣的一阵歌声人语，仿佛笑我们无伴的孤舟哩。东关头转湾，河上的夜色更浓了；临水的妓楼上，时时从帘缝里射出一线一线的灯光；仿佛黑暗从酣睡里眨了一眨眼。我们默然的对着，静听那汩——汩的桨声，几乎要入睡了；朦胧里却温寻着适才的繁华的余味。我那不安的心在静里愈显活跃了！这时我们都有了不足之感，而我的更其浓厚。我们却又不愿回去，于是只能由懊悔而怅惘了。船里便满载着怅惘了。直到利涉桥下，微微嘈杂的人声，才使我豁然一惊；那光景却又不同。右岸的河房里，都大开了窗户，里面亮着晃晃的电灯，电灯的光射到水上，蜿蜒曲折，闪闪不息，正如跳舞着的仙女的臂膊。我们的船已在她的臂膊里了；如睡在摇篮里一样，倦了的我们便又入梦了。那电灯下的人物，只觉得像蚂蚁一般，更不去萦念。这是最后的梦，可惜是最短的梦！黑暗重复落在我们面前，我们看见傍岸的空船上一星两星的，枯燥无力又摇摇不定的灯光。我们的梦醒了，我们知道就要上岸了；我们心里充满了幻灭的情思。
1923年10月11日作完，于温州。</description>
      
    </item>
    
    <item>
      <title>开源项目Tinyhttpd第一篇 详解sockaddr_in，socklen_t，pthread_t</title>
      <link>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%B8%80%E7%AF%87-%E8%AF%A6%E8%A7%A3sockaddr_insocklen/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEtinyhttpd%E7%AC%AC%E4%B8%80%E7%AF%87-%E8%AF%A6%E8%A7%A3sockaddr_insocklen/</guid>
      
        <description>server_sock = startup(&amp;amp;port); printf(&amp;quot;httpd running on port %d\n&amp;quot;, port); while (1) { client_sock = accept(server_sock, (struct sockaddr *)&amp;amp;client_name, &amp;amp;client_name_len); if (client_sock == -1) error_die(&amp;quot;accept&amp;quot;); /* accept_request(&amp;amp;client_sock); */ if (pthread_create(&amp;amp;newthread , NULL, (void *)accept_request, (void *)(intptr_t)client_sock) != 0) perror(&amp;quot;pthread_create&amp;quot;); } close(server_sock); return(0); }
这里面有很多个函数和字段很不常见，具体如下：&amp;lt;br&amp;gt; 1.sockaddr_in 这个结构体是用来用来处理网路通信的地址，它主要是在头文件&amp;lt;netinet/in.h&amp;gt;或&amp;lt;arpa/inet.h&amp;gt;定义的，这个结构体的内部数据结构主要如下: struct sockaddr_in { sa_family sin_family; uint16_t sin_port; struct in_addr sin_addr; char sin_zero[8]; } struct in_addr { In_addr_t s_addr; }
* in_family: 地址家族，可以理解为一系列相似的通信协议的族群，占用2字节，一般它的值主要为AF_INET，AF_INET6和AF_UNSPE。其中AF_INET不能返回任何任何IPV6相关的地址信息，AF_INET6不能返回任何IPV4地址信息，AF_UNSPEC则意味着函数返回的是适用于指定主机名和服务名且适合任何协议族的地址。 * sin_port: 端口号 * sin_addr：IPv4／IPv6地址 * sin_zero[8]:这个奇怪的东西。。。。。我们其实是不用管的，但是说到这个东西必须提到下面这个sockaddr结构，下面这个结构是程序员无法编辑的，即在操作系统中使用的一种socket数据结构，sa_family和上面的定义是一样的，而sa_data则包括上面的端口号和ip地址。sockaddr_in的用处本来是便于程序员进行端口和ip地址的编辑，在系统中会被强行转换成sockaddr，他们两个都是占有16个字节，所以。。。sin_zero[8]就是为了让他们两个保持大小相同而保留的空字节。 struct sockaddr { unsigned short sa_family; char sa_data[14]; };</description>
      
    </item>
    
    <item>
      <title>论药水哥的直播艺术</title>
      <link>https://www.lijunshuo.com/posts/%E8%AE%BA%E8%8D%AF%E6%B0%B4%E5%93%A5%E7%9A%84%E7%9B%B4%E6%92%AD%E8%89%BA%E6%9C%AF/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E8%AE%BA%E8%8D%AF%E6%B0%B4%E5%93%A5%E7%9A%84%E7%9B%B4%E6%92%AD%E8%89%BA%E6%9C%AF/</guid>
      
        <description>药水哥（药酱，叶圣，笨笨，刘波，刘俊生，小浣熊，中南财经政法大学知名硕士毕业生），当初是社会我鑫哥在大学时推荐给我的一个主播，当时他说熊猫有个铁憨憨，玩游戏贼菜还不认，直播间几十万人都在骂他但是他依旧巍然不动。后来我去看他的时候，镜头昏黄，目光呆滞，手里捏着一根烟，头发凌乱，问在干什么，问就说在和美女聊天。后来就中了他的毒，基本天天看，虽然他现在已经整不出活来了，但是我还是他的狗嗨粉哈哈哈哈哈，如果让我来评价他的话，我觉得他是一个很聪明的人，他看起来傻里傻气的，目光呆滞。。但是他在直播过程中懂得如何去拿捏直播的分寸，什么可以播，什么不能播，然后在这个分寸之间触动我们这些狗嗨粉的G点，抓住我们的眼球。总的来说，根据我这两年多来对药水哥的观察和思考，请允许我斗胆将药水哥的艺术时期分为以下几个阶段:
启蒙期（～至2017年10月2日） 实话说，这段时间的资料简直太少了，我能找到的视频资料也很少，我也只能大概的来说在这段时间，药水哥还很稚嫩，当时他还是个很小的主播，直播的节目怎么说呢，真的太尬了，一点内味都没有！！！当时为了节目效果和涨粉丝发了自己一次最强王者的段位截图（反正我是不信他的技术能上最强王者），后来在直播中一直玩卡牌大师，自喻为国服最强卡牌，被直播间粉丝各种喷。。。也就成为药水哥成名的导火索。 参考直播选段： 1. 药水哥RAP 2. 头发巅峰
转折点（艺术的萌芽）(2017年10月3日) 这段我还是最熟悉的，这天我看了当时的录播，当天是个很普通的夜晚，当时药水哥按照日常的惯例和水友连麦，当时水友觉得药水哥玩卡牌大师很菜，还把自己的直播间写上熊猫最强卡牌的字，然后水友开始喷他“最强卡牌？？您配吗？？”药水哥：“敢不敢一直说？谁认怂谁认输”“我跟你干到国庆结束”（要不是我现在用的vscode不能加上滑稽的表情，我肯定在这里加上滑稽的表情！！！）所以这俩傻d从晚上八点一直到凌晨三点，期间水友通过变换腔调不断的去挑衅他，药酱巍然不动，还是用一个半死不活的腔调回应他。一直耗到凌晨三点。。水友和药水坚持不住了，药水在这里突然发力，似乎是积蓄了很久的力量，辅以表情，动作和语调不断的回复水友，最后以水友崩溃和药水胜利的微笑以及药水余音绕梁的话语结束。。。再次我们可以得到一个结论：人类的本质是复读机！！！！！！！！！！ 参考直播选段：您配吗？？
青年期（艺术的探索和高峰阶段）(2017年10月4日至2019年1月直播间被封) 自此以后，药水哥开始了新的直播模式。。也是从这里我每天开始看直播的，在这段时间整活还是最多的最丰富的！！！！！！在这里我还是很有心得的，我们重要分析的是这段时间的直播部分。有的人会说，药水哥的直播方式千变万化，你怎么总结呢，但是话说回来，在世界上，有很多事情万变不离其宗，比如程序就是做事流程的体现，Pascal之父图灵奖大佬Nicklaus Wirth的公式：程序=数据结构+算法，算法就是前文中流程的高度集成，好的，扯远了，废话不多说，用例子来解析，奥利给！！！！！
艺术过度模式（药水早期使用，我最喜欢的那种，内味儿十足） 本范例是一个经典的范例，在视频开始，药水哥发现这个妹妹是个有些高冷的女菩萨，所以他采取此模式，开始时药水哥先礼后兵，后来通过土味情话和这个妹妹找突破口看妹妹是个什么样子的人，通过夸张的表情和抽象的动作来证明自己的试探，后来试探成功，然后一不做二不休，继续通过道具。。扩音器来继续艺术触动水友们的g点。。。后来不知为啥艺术过度，信息量过大，妹妹被吓哭了，药水哥怂了，注意，在这里可以看到药水哥的表情变化，妹妹被吓哭了。。。药水慌了，故采用土味的情话手法和夸张的舞蹈成功逗笑妹妹。b站上面的经典视频大多来自这里。。 总结下来就是：1.先礼后兵 2.试探性艺术 3.加大力度 4.艺术过度 参考直播选段：连麦高冷妹妹
舔狗模式（药水中期使用，内味不足） 这两个范例更不用说也是经典范例，在视频开始，药水哥都是先唠家常，试探一下当前妹妹是个什么性格，然后发现妹妹真的是女菩萨，什么都不懂，太tm善良了（药水最吃这一套了md），然后疯狂装可爱，装舔狗，然后艺术性的装可怜，骗取妹妹的菩萨心，（顺便抓住水友g点，被水友骂，这个时候很多水友会骂药水渣男，还有很多喜欢妹妹在公屏上刷女菩萨）然后采取向妹妹借钱，或者编故事比如药妈去世了，药爹残疾了，药爷等着钱来救等诡异操作，辅以跳舞呀，唱歌呀等手段博取妹妹同情心以后，然后求妹妹见面，然后tmd妹妹就答应了。。。总结下来就是：1.唠家常 2.装可爱/可怜型艺术 3.编故事例如全家升天等惨状骗取妹妹信任 4.求妹妹见面做女朋友 参考直播选段： 1.连麦女菩萨1 2.连麦女菩萨2 伪舔狗模式（药水后期使用，这个时候没有啥内味儿了） 参考视频：连麦拜金妹妹 经典范例！！！！！！在视频开始，药水哥发现这个妹子很漂亮，疯狂舔她，然后通过交流了解到这个妹子是个纯种拜金女以后，拿出道具。。。。范思哲的衣服伪装成土豪勾引妹妹见面，妹妹同意，完成。从该视频我们可以得出，表面上药水哥通过自己疯狂舔狗等各种非常浮夸的的行为博取妹妹的心，实际上来说从药水哥的动作又反映出生活中拜金的恶臭和舔狗疯狂演绎的无奈！！！就像那句老话说的，好看的皮囊千般一律，有趣的灵魂万里挑一。 总结下来就是：1.舔 2.跪着舔 3.趴着舔 被教育模式 这个。。。属于连麦失误，这种范例真的很少，但是药水好像应付得来，刚开始药水和她聊天之后，发现他是个心思缜密的人，决定先采取一些手段挑衅这个妹子，和妹子发生一些争论，然后药水想通过自己的逻辑想让妹子钻到自己的套里面。。。但是来妹子的心思缜密的不钻他的套哈哈哈哈哈哈哈，进而成为一种新的艺术，其实这八十分钟就像拳击一样，药水和妹子打得有来有回，不分伯仲。最后药水艺术失败，我感觉这是这次直播最精彩的一点了！！！ 参考直播选段： 1.逻辑艺术1 2.逻辑艺术2 疯狂嘲讽模式 连麦gay佬 md，不予评论，无法接受这样子诡异的聊天，嘴臭就完事了，正在看这片文章的大佬们自己去看吧！！！！！！ 4.老年期（在虎牙直播开播以来至今） 这个怎么说，现在就是说，连麦以后各种ghs，连麦以后，几分钟之内疯狂问吃饭了吗。。。然后让妹妹各种换衣服ghs。。。恶臭，一点内味都没有！！！！&amp;lt;/br写这篇文章的目的是心血来潮，五一期间没有办法出去，只能在宿舍看看书，写写博客一类的，突然感觉最近的药水哥收敛了很多，唏嘘不已，艺术已死，药朗才尽。。。4月底时的直播药水说要在五月份更改直播模式，希望药水能吸取以前直播的经验，多多整活，给我们这些狗嗨粉多一些骂他的理由哈哈哈哈哈～～～学习了学习了！！！！转载请注明出处，谢谢！！！！！！ </description>
      
    </item>
    
    <item>
      <title>详解算法 最长连续子序列系列问题</title>
      <link>https://www.lijunshuo.com/posts/%E8%AF%A6%E8%A7%A3%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E8%AF%A6%E8%A7%A3%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</guid>
      
        <description>常规最长连续子序列问题 通常这个算法的问题主要形式主要是给定一个无序的整数数组，然后找出最长连续子序列的长度,以下代码全部基于C++语言进行演示 常规解法 这种解法是正常人刚开始看到这个问题时，头脑中冒出的第一种解法，这个解法认为这个数组开始的每个数字都是一个连续数组的开头，然后从这个起点开始遍历知道剩下的数字有没有相对上一个数字连续的数字，一直迭代到不存在的某个数字，顺便记录最大的连续子序列长度。 bool isContain(int arr[],int arrLength,int num) { for(int i=0;i&amp;lt;arrLength;i++) { if(arr[i]==num)return true; return false; } } int longestContinueArray(int arr[]) { int longestStreak=0; int arrLenth=arr.length; for(int num:arr) { int currentNum=num; int currentStreak=1; while(isContain(arr,arrLength,currentNum)) { currentNum+=1; currentStreak+=1; } longestStreak=Math.max(longestStreak,currentStreak); } return longestStreak; } 这种算法的话时间复杂度是非常糟糕的（因为一般来说刚开始解决问题时的头一个方法永远是一个最复杂的方法。。。最简单的一般都是最复杂的），因为他的时间复杂度大概为O(n^3)。所以我们现在考虑如何优化这个算法，首先因为我们要找的是个连续序列，所以可以先进行排序和去重，这样子可以省掉n个时间复杂度的查找时间；然后我们必须考虑程序中提供的数组是不是为空，如果为空或者为null的话我们应该考虑以下如何处理这种错误情况；最后我们发现我们在遍历过程中出现了大量的重复过程比如：
1,2,7,3,4,5 比如上面这个数组的最长连续子序列肯定是5，然后我们根据上面那个算法可以发现，当for循环中的num为1时，能够查到的最长序列为5，当num为2时，我们发现我们的现在查到的以前已经查过了，想办法不查这一部分可以大大优化整个算法的时间复杂度：
int longestContinueArray(int []arr) { if(arr==null||arr.length==0)return 0; Array.sort(arr); int longestStreak=1; int currentStreak=1; for(int i=1;i&amp;lt;arr.length;i++) { if(i+1&amp;lt;arr.length&amp;amp;&amp;amp;arr[i]+1==arr[i+1]) currentStreak++; else { longestStreak=Math.max(longestStreak,currentStreak); currentStreak=1; } } return longestStreak; } 以上代码解决了以上的问题，但是时间复杂度最优为nlogn, 最差为n^2,其实我们完全可以用c++一些提供的特定结构来进一步简化整体算法的时间复杂度。比如我们可以使用C++中的set，自动去重且查询为O(1)</description>
      
    </item>
    
    <item>
      <title>详解Excel读取方式</title>
      <link>https://www.lijunshuo.com/posts/%E8%AF%A6%E8%A7%A3excel%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E8%AF%A6%E8%A7%A3excel%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F/</guid>
      
        <description>string path=&amp;#34;&amp;#34;//这里定义了excel文件的文件位置 string key= &amp;#34;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&amp;#34; + path + &amp;#34;;Extended Properties=&amp;#39;Excel 8.0;HDR=NO;IMEX=1&amp;#39;;&amp;#34;; OledbConnection connection =new OledbConnection(key); connection.Open(); string sql=&amp;#34;select * from [sheet1$]&amp;#34;; OledbDataAdapter adapter=new OledbDataAdapter(sql,connection); DataSet tempDataSet=new DataSet(); adapter.Fill(tempDataSet); 首先，在c#中数据表是这样子的，c#中有DataSet和DataTable两个关键字，然后我们可以理解DataSet是一类数据表的集合，他是在内存中的虚拟表的集合；DataTable是一种在内存中的虚拟表，他可以存储任何表的数据。。。这么说好抽象，其实可以这样子理解，DataTable是一张a4纸，然后a4纸上画着表格存着很多数据，DataSet就是一沓a4纸啦！！！！
前情已经讲述完成，oledb，是一种数据库的方式，其实oledb是早期odbc连接方式的加强版，微软设计出这种应用程序接口是为了连接关系型数据库和非关系型数据库还有其他的奇怪的数据库，说白了是为了隔离每种数据库操作的差异，在我用过的连接比如说sql server和access数据库来说，都是先通过一串字符串来定义一个连接，就是我上面写的那个string类型的key，具体如下：
/连接Sql Server string key=&amp;#34;PROVIDER=SQLOLEDB;DATA SOURCE=servername;UID=xyz;PWD=xxx;DATABASE=dbname&amp;#34; //连接 Microsoft Access string key= &amp;#34;PROVIDER=MICROSOFT.JET.OLEDB.4.0;DATA SOURCE=d:\abc\defg.mdb&amp;#34; //连接 Microsoft Excel 07版本及老版本 string key=&amp;#34;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&amp;#34; + Path + &amp;#34;;&amp;#34; + &amp;#34;Extended Properties=\&amp;#34;Excel 12.0;HDR=NO;IMEX=1;\&amp;#34;&amp;#34; //连接 Microsoft Excel 07版本及新版本 string key=&amp;#34;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&amp;#34; + strExcelPath + &amp;#34;;&amp;#34; + &amp;#34;Extended Properties=\&amp;#34;Excel 8.</description>
      
    </item>
    
    <item>
      <title>对羊哥博客搭建教程的补充</title>
      <link>https://www.lijunshuo.com/posts/%E5%AF%B9%E7%BE%8A%E5%93%A5%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%E7%9A%84%E8%A1%A5%E5%85%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.lijunshuo.com/posts/%E5%AF%B9%E7%BE%8A%E5%93%A5%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%E7%9A%84%E8%A1%A5%E5%85%85/</guid>
      
        <description>链接：羊哥博客搭建教程 实话说，在羊哥搭建博客教学视频中，他的教程已经很详细的了，在mac下都能按照他的情况搭建出来，但是有一个部分值得注意，就是有关于头像图片和其他图片无法显示的问题。我为了解决这个问题，查阅了百度上的很多资料，踩了很多坑，总结出一个方法仅供参考。 在我的理解中，博客网页上所有的图片等资源都存在source文件夹内，其中source/_posts在创建时就存在，主要是存储md格式的博客文字。所以我们可以在source文件中新建一个文件夹来存储图片，我在这里将其命名为img，在其中添加两个图片，Alipay（支付宝二维码）和Head（头像），接下来在_config.yml文件中配置这两个图片（注意在这里的_config.yml是themes主题中的某个主题的配置文件，而不是hexo框架的配置文件）
# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: /img/Alipay.jpeg #你的头像url avatar: /img/Head.JPG </description>
      
    </item>
    
  </channel>
</rss>